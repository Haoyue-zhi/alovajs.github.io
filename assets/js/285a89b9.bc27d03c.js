"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[779],{9664:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>d,frontMatter:()=>n,metadata:()=>i,toc:()=>c});var r=s(5893),o=s(1151);const n={title:"Parallel Requests",sidebar_position:120},a=void 0,i={id:"tutorial/getting-started/parallel-request",title:"Parallel Requests",description:"Use method",source:"@site/docs/tutorial/02-getting-started/12-parallel-request.md",sourceDirName:"tutorial/02-getting-started",slug:"/tutorial/getting-started/parallel-request",permalink:"/tutorial/getting-started/parallel-request",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/02-getting-started/12-parallel-request.md",tags:[],version:"current",sidebarPosition:120,frontMatter:{title:"Parallel Requests",sidebar_position:120},sidebar:"tutorialSidebar",previous:{title:"Share Request",permalink:"/tutorial/getting-started/share-request"},next:{title:"Serial request",permalink:"/tutorial/getting-started/serial-request"}},l={},c=[{value:"Use method",id:"use-method",level:2},{value:"Use useRequeset",id:"use-userequeset",level:2},{value:"Approach 1",id:"approach-1",level:3},{value:"Approach 2",id:"approach-2",level:3}];function u(e){const t={code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h2,{id:"use-method",children:"Use method"}),"\n",(0,r.jsxs)(t.p,{children:["Due to the method is a PromiseLike instance, you only need to wait for the method to complete the parallel request by using ",(0,r.jsx)(t.code,{children:"Promise.all"}),"."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const [todoList, todoCounter] = await Promise.all[(todoListGetter, todoCountGetter)];\n"})}),"\n",(0,r.jsx)(t.h2,{id:"use-userequeset",children:"Use useRequeset"}),"\n",(0,r.jsx)(t.p,{children:"Simple parallel requests only need to call multiple useRequest at the same time."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const { data: todoList } = useRequest(todoListGetter);\r\nconst { data: todoCounter } = useRequest(todoCountGetter);\n"})}),"\n",(0,r.jsx)(t.p,{children:"But this kind of request is only suitable for pure parallel requests. If you need to perform some operations after the parallel requests are completed, there are two ways to achieve it:"}),"\n",(0,r.jsx)(t.h3,{id:"approach-1",children:"Approach 1"}),"\n",(0,r.jsxs)(t.p,{children:["Create promise objects manually, and use ",(0,r.jsx)(t.code,{children:"Promise.all"})," to complete the effect."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const { data: todoList, onSuccess: onListSuccess, onError: onListError } = useRequest(todoListGetter);\r\nconst { data: todoCounter, onSuccess: onCountSuccess, onError: onCountError } = useRequest(todoCountGetter);\r\n\r\n// Manually create the promise object\r\nconst listPromise = new Promise((resolve, reject) => {\r\n  onListSuccess(resolve);\r\n  onListError(reject);\r\n});\r\nconst countPromise = new Promise((resolve, reject) => {\r\n  onCountSuccess(resolve);\r\n  onCountError(reject);\r\n});\r\nconst [listEvent, countEvent] = await Promise.all([listPromise, countPromise]);\r\n// The parallel request is completed, continue to process the business...\n"})}),"\n",(0,r.jsx)(t.h3,{id:"approach-2",children:"Approach 2"}),"\n",(0,r.jsxs)(t.p,{children:["Using the ",(0,r.jsx)(t.code,{children:"send"})," function returned by the ",(0,r.jsx)(t.code,{children:"useRequest"})," function, calling ",(0,r.jsx)(t.code,{children:"send"})," will return an available promise object."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"// Let them not automatically send requests first\r\nconst { send: sendList } = useRequest(todoListGetter, { immediate: false });\r\nconst { send: sendCount } = useRequest(todoCountGetter, { immediate: false });\r\n\r\n// Use the promise object returned by the send function\r\nconst parallelRequest = async () => {\r\n  const [listResponse, countResponse] = await Promise.all([sendList(), sendCount()]);\r\n  // The parallel request is completed, continue to process the business...\r\n};\n"})})]})}function d(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},1151:(e,t,s)=>{s.d(t,{Z:()=>i,a:()=>a});var r=s(7294);const o={},n=r.createContext(o);function a(e){const t=r.useContext(n);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(n.Provider,{value:t},e.children)}}}]);