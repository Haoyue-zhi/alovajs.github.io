"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[4507],{9482:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var r=n(5893),a=n(1151);const s={title:"method metadata",sidebar_position:35},o=void 0,i={id:"tutorial/next-step/method-metadata",title:"method metadata",description:"v2.7.0+",source:"@site/docs/tutorial/06-next-step/04-method-metadata.md",sourceDirName:"tutorial/06-next-step",slug:"/tutorial/next-step/method-metadata",permalink:"/tutorial/next-step/method-metadata",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/06-next-step/04-method-metadata.md",tags:[],version:"current",sidebarPosition:35,frontMatter:{title:"method metadata",sidebar_position:35},sidebar:"tutorialSidebar",previous:{title:"Use method to request",permalink:"/tutorial/next-step/send-request-directly"},next:{title:"Method instance matcher",permalink:"/tutorial/next-step/method-instance-matcher"}},d={},c=[{value:"Use metadata to identify identities",id:"use-metadata-to-identify-identities",level:2},{value:"Use the identity before the request",id:"use-the-identity-before-the-request",level:3},{value:"Use identity after response",id:"use-identity-after-response",level:3},{value:"Use metadata to pass data",id:"use-metadata-to-pass-data",level:2},{value:"Prompt for non-typescript projects",id:"prompt-for-non-typescript-projects",level:2}];function l(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.admonition,{title:"version requirements",type:"info",children:(0,r.jsx)(t.p,{children:"v2.7.0+"})}),"\n",(0,r.jsx)(t.p,{children:"Method instances run through the entire request life cycle of alova, and there are a large number of different method instances in the project. Sometimes we need to add additional information to specific method instances in order to identify them or pass additional information Wait, at this point, we need to use method metadata."}),"\n",(0,r.jsx)(t.h2,{id:"use-metadata-to-identify-identities",children:"Use metadata to identify identities"}),"\n",(0,r.jsx)(t.h3,{id:"use-the-identity-before-the-request",children:"Use the identity before the request"}),"\n",(0,r.jsxs)(t.p,{children:["For example, most of the interfaces in your project need to be accompanied by ",(0,r.jsx)(t.code,{children:"token"})," for each request, but there are still some interfaces that do not need to be verified, and you may handle them uniformly in the global ",(0,r.jsx)(t.code,{children:"beforeRequest"})," function."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const nonvalidateRequiredApi = [\r\n  '/api/url1',\r\n  '/api/url2',\r\n  '/api/url3'\r\n  //...\r\n];\r\n\r\ncreateAlova({\r\n  beforeRequest(method) {\r\n    if (!nonvalidateRequiredApi.includes(method.url)) {\r\n      method.config.headers.token = '...';\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"This will cause the following two problems:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"The information is not aggregated with the method instance, and the maintainability is worse;"}),"\n",(0,r.jsx)(t.li,{children:"Coding is more troublesome;"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"To solve these two problems, we will use metadata to identify a specific method instance when it is created."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Step 1: Define metadata when creating a method instance"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const loginAPI = (username, password) => {\r\n  const methodInstance = alovaInst.Post('/login', {\r\n    username,\r\n    password\r\n  });\r\n  methodInstance.meta = {\r\n    ignoreToken: true\r\n  };\r\n  return methodInstance;\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Step 2: Use metadata as the basis for judgment in ",(0,r.jsx)(t.code,{children:"beforeRequest"})]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"createAlova({\r\n  //...\r\n  beforeRequest(method) {\r\n    if (!method.meta?.ignoreToken) {\r\n      method.config.headers.token = '...';\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.h3,{id:"use-identity-after-response",children:"Use identity after response"}),"\n",(0,r.jsxs)(t.p,{children:["This method can also be used in the global ",(0,r.jsx)(t.code,{children:"responded"}),". For example, in most cases, the request api will return json data, but there may be a file download interface, which will return a binary data stream. In this case Next, you can use different metadata in ",(0,r.jsx)(t.code,{children:"responded"})," to handle different responses separately."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Step 1: When creating a method instance, you also need to assign a metadata"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const downloadAPI = filePath => {\r\n  const methodInstance = alovaInst.Post('/download_file', {\r\n    filePath\r\n  });\r\n  methodInstance.meta = {\r\n    isDownload: true\r\n  };\r\n  return methodInstance;\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Step 2: Use metadata as the basis for judgment in ",(0,r.jsx)(t.code,{children:"responded"})]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"createAlova({\r\n   //...\r\n   responded:\r\n     onSuccess: (response, method) => method.meta?.isDownload ? response.blob() : response.json()\r\n     onError: (error, method) => {\r\n       // You can also access the metadata of the method instance when responding to errors\r\n     }\r\n   }\r\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"use-metadata-to-pass-data",children:"Use metadata to pass data"}),"\n",(0,r.jsx)(t.p,{children:"In some cases, if you want to add additional information to different method instances for use elsewhere, you can also use metadata to save it. Take the uniform generation of different method instance ids as an example."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"createAlova({\r\n  beforeRequest(method) {\r\n    if (!method.meta.generateId) {\r\n      method.meta.uid = generateUUID();\r\n    }\r\n  },\r\n\r\n  responded: {\r\n    onSuccess(response, method) {\r\n      // Access the meta data generated by the current method in a successful request\r\n      const currentMethodUID = method.meta.uid;\r\n    },\r\n    onError(error, method) {\r\n      // Access the meta data generated by the current method in the request failure\r\n      const currentMethodUID = method.meta.uid;\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"prompt-for-non-typescript-projects",children:"Prompt for non-typescript projects"}),"\n",(0,r.jsxs)(t.p,{children:["In a non-typescript environment, you can use any attribute as an information carrier, not limited to the ",(0,r.jsx)(t.code,{children:"meta"})," attribute."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"methodInstance.showResponseMsg = true;\r\nmethodInstance.others = 'abc';\n"})}),"\n",(0,r.jsxs)(t.p,{children:["It\u2019s just that in the typescript environment, any property name will report ",(0,r.jsx)(t.code,{children:"the property \u201c$0\u201d does not exist. ts(2339)"}),", so in the type we specify the ",(0,r.jsx)(t.code,{children:"meta"})," attribute as the information carrier."]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>o});var r=n(7294);const a={},s=r.createContext(a);function o(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);