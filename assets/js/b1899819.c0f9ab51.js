"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[9847],{7730:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var s=n(5893),o=n(1151);const r={title:"Controlled Caching",sidebar_position:90},a=void 0,i={id:"tutorial/next-step/controlled-cache",title:"Controlled Caching",description:"v2.1.0+",source:"@site/docs/tutorial/06-next-step/10-controlled-cache.md",sourceDirName:"tutorial/06-next-step",slug:"/tutorial/next-step/controlled-cache",permalink:"/tutorial/next-step/controlled-cache",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/06-next-step/10-controlled-cache.md",tags:[],version:"current",sidebarPosition:90,frontMatter:{title:"Controlled Caching",sidebar_position:90},sidebar:"tutorialSidebar",previous:{title:"Serial request",permalink:"/tutorial/next-step/serial-request"},next:{title:"Download/Upload progress",permalink:"/tutorial/next-step/download-upload-progress"}},c={},l=[];function d(e){const t={a:"a",admonition:"admonition",code:"code",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.admonition,{title:"version required",type:"info",children:(0,s.jsx)(t.p,{children:"v2.1.0+"})}),"\n",(0,s.jsxs)(t.p,{children:["When sending a request, by default, it will first check whether there is matching cache data, and if it matches, it will use it as the response data to return. If in some scenarios, the user needs to use a custom cache, he must first use ",(0,s.jsx)(t.code,{children:"setCache"})," to synchronize It is only feasible to set cached data, which undoubtedly increases the burden on users. This is an uncontrolled cache."]}),"\n",(0,s.jsxs)(t.p,{children:["If you want to use such ",(0,s.jsx)(t.strong,{children:"IndexedDB"})," to custom management cache data with uncontrolled caching, you may first pre-set the hit cache for upcoming requests, like this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const getFile = fileName => {\r\n  const fileGetter = alovaInstance.GET(`/file/${fileName}`);\r\n  const tx = db.transaction(['files']);\r\n  const getRequest = tx.objectStore('files').get(fileName);\r\n  getRequest.onsuccess = ({ result }) => {\r\n    setCache(fileGetter, result);\r\n  };\r\n  return fileGetter;\r\n};\n"})}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.strong,{children:"\u274c But the usage above is not recommended"}),", for the following reasons:"]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["Each call to ",(0,s.jsx)(t.code,{children:"getFile"})," will set up a cache, but fileGetter is not necessarily used to send requests;"]}),"\n",(0,s.jsx)(t.li,{children:"IndexedDB is an asynchronous interface. If the step of matching the cache occurs before IndexedDB triggers onsuccess, then the cached data will not be matched, and their order is unpredictable;"}),"\n",(0,s.jsx)(t.li,{children:"Custom cache management tasks and methods are separate, but in fact they should be aggregated together;"}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:"In this case, you can use controlled caching to solve the above problem. Using controlled caching is also very simple. You can set localCache in the method as an asynchronous or synchronous function, and return custom data as a hit in this function The cached data is returned."}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const getFile = fileName =>\r\n  alovaInstance.GET(`/file/${fileName}`, {\r\n    // Controlled caching functions support asynchronous and synchronous functions\r\n    localCache() {\r\n      return new Promise((resolve, reject) => {\r\n        const tx = db.transaction(['files']);\r\n        const getRequest = tx.objectStore('files').get(fileName);\r\n        getRequest.onsuccess = resolve;\r\n        getRequest.onerror = reject;\r\n      });\r\n    }\r\n  });\n"})}),"\n",(0,s.jsxs)(t.p,{children:["If you want to continue sending requests, you can return undefined or no data in ",(0,s.jsx)(t.code,{children:"localCache"}),", which is useful in case of a cache miss when customizing the managed cache."]}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["You can also use ",(0,s.jsx)(t.a,{href:"/tutorial/learning/transform-response-data",children:"special usage of transformData"})," to implement custom cache storage tasks."]}),"\n",(0,s.jsxs)(t.li,{children:["When used in usehooks, throwing an error in the ",(0,s.jsx)(t.code,{children:"localCache"})," function will trigger ",(0,s.jsx)(t.code,{children:"onError"}),", and when using the method instance to request directly, a rejected promise will be returned."]}),"\n"]})]})}function h(e={}){const{wrapper:t}={...(0,o.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>a});var s=n(7294);const o={},r=s.createContext(o);function a(e){const t=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(r.Provider,{value:t},e.children)}}}]);