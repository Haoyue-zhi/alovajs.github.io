"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[4050],{1862:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>h});var i=a(5893),n=a(1151);const o={title:"Automatic cache invalidation",sidebar_position:20},s=void 0,c={id:"tutorial/cache/auto-invalidate",title:"Automatic cache invalidation",description:"There is a scenario where when the user clicks on an item in the todo list, enters the todo details page and edits it, at this time we hope that the todo list data on the previous page will also be updated with the edited content. Usually The approach is to trigger content updates on the previous page through events, which increases maintenance costs. And alova provides 3 ways to achieve this goal very elegantly:",source:"@site/docs/tutorial/03-cache/02-auto-invalidate.md",sourceDirName:"tutorial/03-cache",slug:"/tutorial/cache/auto-invalidate",permalink:"/tutorial/cache/auto-invalidate",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/03-cache/02-auto-invalidate.md",tags:[],version:"current",sidebarPosition:20,frontMatter:{title:"Automatic cache invalidation",sidebar_position:20},sidebar:"tutorialSidebar",previous:{title:"Cache mode",permalink:"/tutorial/cache/mode"},next:{title:"Invalidate Response Cache manually",permalink:"/tutorial/cache/manually-invalidate"}},r={},h=[{value:"scenes to be used",id:"scenes-to-be-used",level:2},{value:"Set automatic invalidation rules",id:"set-automatic-invalidation-rules",level:2},{value:"Invalidation source is set to method instance",id:"invalidation-source-is-set-to-method-instance",level:3},{value:"Match invalidating source by method name",id:"match-invalidating-source-by-method-name",level:3},{value:"Match invalidating source by regexp of method name",id:"match-invalidating-source-by-regexp-of-method-name",level:3},{value:"Combination setting validating source",id:"combination-setting-validating-source",level:3},{value:"hitSource data type",id:"hitsource-data-type",level:2}];function l(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)(t.p,{children:["There is a scenario where when the user clicks on an item in the todo list, enters the todo details page and edits it, at this time we hope that the todo list data on the previous page will also be updated with the edited content. Usually The approach is to trigger content updates on the previous page through events, which increases maintenance costs. And ",(0,i.jsx)(t.code,{children:"alova"})," provides 3 ways to achieve this goal very elegantly:"]}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Use ",(0,i.jsx)(t.code,{children:"useFetcher"})," to immediately re-request the latest data, which will be explained in the ",(0,i.jsx)(t.a,{href:"/tutorial/advanced/data-fetching",children:"Data Fetching"})," chapter;"]}),"\n",(0,i.jsxs)(t.li,{children:["Update the cache. This method will be explained in detail in the ",(0,i.jsx)(t.a,{href:"/tutorial/cache/set-and-query",children:"Cache set and query"})," chapter later;"]}),"\n",(0,i.jsx)(t.li,{children:"Invalidate the response cache. When requested again, the data will be requested again due to cache invalidation. This is also what this chapter will explain."}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Automatic cache invalidation is to set invalidation source rules in the target cache. As long as the rules match, the target cache can be automatically invalidated. This saves the trouble of manually clearing the cache in many cases."}),"\n",(0,i.jsx)(t.h2,{id:"scenes-to-be-used",children:"scenes to be used"}),"\n",(0,i.jsx)(t.p,{children:"Setting up automatic invalidation rules is convenient when the target cache is one-to-one or one-to-many with the invalidation source."}),"\n",(0,i.jsx)(t.mermaid,{value:"flowchart\r\n   M1[method1 invalidation source points to] --\x3e T1[target cache]\r\n   M11[method1 invalidation source points to] --\x3e T2[target cache]\r\n   M2[method2 invalidation source points to] --\x3e T2[target cache]\r\n   MN[methodN invalidation source points to] --\x3e T2[target cache]"}),"\n",(0,i.jsx)(t.h2,{id:"set-automatic-invalidation-rules",children:"Set automatic invalidation rules"}),"\n",(0,i.jsxs)(t.p,{children:["Setting this rule is very simple, you can set the ",(0,i.jsx)(t.code,{children:"hitSource"})," parameter for it when creating a Method instance with caching."]}),"\n",(0,i.jsx)(t.h3,{id:"invalidation-source-is-set-to-method-instance",children:"Invalidation source is set to method instance"}),"\n",(0,i.jsx)(t.p,{children:"With a fixed method instance as the invalidation source, as long as the method instance or its clone instance succeeds, the target cache will be cleared automatically."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"alova.Get('/todo/1', {\r\n  //...\r\n  hitSource: alova.Post('/todo', {})\r\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"match-invalidating-source-by-method-name",children:"Match invalidating source by method name"}),"\n",(0,i.jsx)(t.p,{children:"Like the method instance matcher, you can specify the name of the method in hitSource to match the failure source. Multiple failure sources can be set to the same name. When the method instance request with this name succeeds, the target cache will be automatically cleared."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"const methodSubmitTodo = data =>\r\n  alova.Post('/todo', data, {\r\n    name: 'submitTodo'\r\n  });\r\n\r\nalova.Get('/todo/1', {\r\n  //...\r\n  // Match the failure source whose method instance name is submitTodo\r\n  hitSource: 'submitTodo'\r\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"match-invalidating-source-by-regexp-of-method-name",children:"Match invalidating source by regexp of method name"}),"\n",(0,i.jsx)(t.p,{children:"If the method instance name is not fixed, you can specify a regular expression in hitSource to match the method name, and the target cache will be automatically cleared when the matched method instance succeeds in the request."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"const methodSubmitTodo = data =>\r\n  alova.Post('/todo', data, {\r\n    name: 'prefix-submitTodo'\r\n  });\r\n\r\nalova.Get('/todo/1', {\r\n  //...\r\n  // Match all instances whose method instance name starts with prefix\r\n  hitSource: /^prefix/\r\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"combination-setting-validating-source",children:"Combination setting validating source"}),"\n",(0,i.jsx)(t.p,{children:"If you want to use the above multiple rules to match failure sources, you can specify hitSource as an array, and the array item is any one of the above three rules, and the method instance that meets any one of the rules in the array will be matched."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"alova.Get('/todo/1', {\r\n  //...\r\n  // When the method instance request that satisfies any matching rule in the array succeeds, the cache will be invalidated\r\n  hitSource: [alova.Post('/todo', {}), 'submitTodo', /^prefix/]\r\n});\n"})}),"\n",(0,i.jsx)(t.h2,{id:"hitsource-data-type",children:"hitSource data type"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"type hitSource = string | RegExp | Method | (string | RegExp | Method)[];\n"})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}},1151:(e,t,a)=>{a.d(t,{Z:()=>c,a:()=>s});var i=a(7294);const n={},o=i.createContext(n);function s(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:s(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);