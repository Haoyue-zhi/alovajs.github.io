"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[6226],{8734:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>l,default:()=>p,frontMatter:()=>o,metadata:()=>d,toc:()=>u});var a=n(5893),r=n(1151),i=n(4866),s=n(5162);const o={title:"Step 2 - Adjust Response Handling",sidebar_position:50},l=void 0,d={id:"tutorial/strategy/sensorless-data-interaction/modify-response",title:"Step 2 - Adjust Response Handling",description:"In the conservative request example in the previous section, we called fetch to re-fetch the refreshed page after creating, editing, and deleting requests for Todo items. In order to display the results immediately after the operation, we need to make the following adjustments:",source:"@site/docs/tutorial/07-strategy/01-sensorless-data-interaction/05-modify-response.md",sourceDirName:"tutorial/07-strategy/01-sensorless-data-interaction",slug:"/tutorial/strategy/sensorless-data-interaction/modify-response",permalink:"/tutorial/strategy/sensorless-data-interaction/modify-response",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/07-strategy/01-sensorless-data-interaction/05-modify-response.md",tags:[],version:"current",sidebarPosition:50,frontMatter:{title:"Step 2 - Adjust Response Handling",sidebar_position:50},sidebar:"tutorialSidebar",previous:{title:"Step 1 - Implement features with conservative requests",permalink:"/tutorial/strategy/sensorless-data-interaction/conservative-request"},next:{title:"Step 3 - Set Request Retry",permalink:"/tutorial/strategy/sensorless-data-interaction/request-retry"}},c={},u=[{value:"Set behavior mode",id:"set-behavior-mode",level:2},{value:"Silent queue description",id:"silent-queue-description",level:2},{value:"Manually update the list in the callback",id:"manually-update-the-list-in-the-callback",level:2},{value:"Update the list after adding/editing",id:"update-the-list-after-addingediting",level:3},{value:"Update list after removal",id:"update-list-after-removal",level:3},{value:"Save the operation record",id:"save-the-operation-record",level:2},{value:"create/edit success callback",id:"createedit-success-callback",level:3},{value:"delete success callback",id:"delete-success-callback",level:3},{value:"Precautions",id:"precautions",level:3}];function h(e){const t={a:"a",blockquote:"blockquote",code:"code",em:"em",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,r.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(t.p,{children:["In the conservative request example in the previous section, we called ",(0,a.jsx)(t.code,{children:"fetch"})," to re-fetch the refreshed page after creating, editing, and deleting requests for Todo items. In order to display the results immediately after the operation, we need to make the following adjustments:"]}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["Set the behavior mode of create, edit and delete requests to ",(0,a.jsx)(t.code,{children:"silent"}),", they will trigger the success callback immediately when the request is made;"]}),"\n",(0,a.jsx)(t.li,{children:"Manually update the list, instead of pulling data, use virtual data to occupy the response data of the server;"}),"\n",(0,a.jsx)(t.li,{children:"Save operation records for data compensation when refreshing the page;"}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"set-behavior-mode",children:"Set behavior mode"}),"\n",(0,a.jsxs)(t.p,{children:["Set by configuring the parameter ",(0,a.jsx)(t.code,{children:"behavior"}),", the optional parameters are ",(0,a.jsx)(t.code,{children:"queue"}),", ",(0,a.jsx)(t.code,{children:"silent"}),", ",(0,a.jsx)(t.code,{children:"static"}),", or a function that returns behavior data to dynamically set the behavior mode, the default is ",(0,a.jsx)(t.code,{children:"queue"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"The following sets the behavior parameters statically."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n  // highlight-start\r\n  behavior: 'silent',\r\n  // highlight-end\r\n  immediate: false\r\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"The following is to dynamically set the behavior parameter."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"const { send } = useSQRequest(createOrEditTodo, {\r\n  // highlight-start\r\n  // The arg parameter can be passed in through the send function\r\n  behavior: arg => {\r\n    if (arg === 0) return 'silent';\r\n    return 'queue';\r\n  },\r\n  // highlight-end\r\n  immediate: false\r\n});\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"When behavior is set as a function, it will be called every time a request is initiated to determine which behavior to process this request."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"silent-queue-description",children:"Silent queue description"}),"\n",(0,a.jsxs)(t.p,{children:["After setting the behavior parameter to ",(0,a.jsx)(t.code,{children:"queue"})," or ",(0,a.jsx)(t.code,{children:"silent"}),", the request will enter the silent queue and wait for the request to be initiated. By default, they will enter the queue named ",(0,a.jsx)(t.code,{children:"default"}),". You can also specify other queues to save silentMethod instances. without interfering with each other."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n  // highlight-start\r\n  // The specified request information enters the queue named queue-2\r\n  queue: 'queue-2',\r\n  // highlight-end\r\n  behavior: 'silent',\r\n  immediate: false\r\n});\n"})}),"\n",(0,a.jsx)(t.h2,{id:"manually-update-the-list-in-the-callback",children:"Manually update the list in the callback"}),"\n",(0,a.jsx)(t.h3,{id:"update-the-list-after-addingediting",children:"Update the list after adding/editing"}),"\n",(0,a.jsxs)(i.Z,{children:[(0,a.jsxs)(s.Z,{value:"1",label:"Page is not destroyed",children:[(0,a.jsxs)(t.p,{children:["When the list page is not destroyed, such as using the modal box operation on the current page, or using ",(0,a.jsx)(t.code,{children:"<keep-alive>"})," (Vue) to keep the page components, the data will still exist. At this time, we use ",(0,a.jsx)(t.strong,{children:"updateStateEffect"})," to Update the list data. Compared with the ",(0,a.jsx)(t.strong,{children:"updateState"})," exported by alova, it has the function of tracking virtual data. When the response data is obtained, it will automatically track the virtual data in the list data and replace it with the actual data."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"import { useSQRequest, updateStateEffect } from '@alova/scene-*';\r\nimport { createOrEditTodo, todoList } from './api.js';\r\n\r\nconst { onSuccess } = useSQRequest(createOrEditTodo, {\r\n  behavior: 'silent',\r\n  immediate: false,\r\n\r\n  // highlight-start\r\n  // Before processing list updates, it is necessary to construct virtual response data of the same structure according to the structure of the response data\r\n  // For example, when creating a Todo item, the id of this piece of data will be returned.\r\n  silentDefaultResponse: () => {\r\n    return {\r\n      id: '--'\r\n    };\r\n  }\r\n  // highlight-end\r\n});\r\n\r\n// highlight-start\r\nonSuccess(({ data, silentMethod }) => {\r\n  // Construct list data items\r\n  const editingItem = {\r\n    ...detail,\r\n\r\n    // When editing, use the original id, otherwise use the id in the response data\r\n    // When submitting silently, data.id is virtual data, and when in static behavior mode, data.id is the actual id value\r\n    id: id || data.id\r\n  };\r\n\r\n  // use updateStateEffect instead of updateState\r\n  updateStateEffect(todoList(), todoListRaw => {\r\n    if (id) {\r\n      todoListRaw = todoListRaw.map(item => (item.id === id ? editingItem : item));\r\n    } else {\r\n      todoListRaw.unshift(editingItem);\r\n    }\r\n    return todoListRaw;\r\n  });\r\n});\r\n// highlight-end\n"})}),(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsxs)(t.p,{children:["updateStateEffect is used in the same way as ",(0,a.jsx)(t.a,{href:"/tutorial/learning/update-response-data-across-modules",children:"updateState"})]}),"\n"]})]}),(0,a.jsxs)(s.Z,{value:"2",label:"Page has been destroyed",children:[(0,a.jsxs)(t.p,{children:["When the list page has been destroyed and the data has been released, such as jumping to a new page, use ",(0,a.jsx)(t.strong,{children:"setCache"})," to update the cache data. When the list page is returned, the request will be re-initiated and the updated cache will be hit."]}),(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"import { useSQRequest, setCache, equals } from '@alova/scene-*';\r\nimport { createOrEditTodo, todoList } from './api.js';\r\n\r\nconst urlParams = new URLSearchParams(window.location.search);\r\nconst id = urlParams.get('id') || '';\r\nconst { onSuccess } = useSQRequest(createOrEditTodo, {\r\n   behavior: 'silent',\r\n   immediate: false,\r\n\r\n   // highlight-start\r\n   // Before processing list updates, it is necessary to construct virtual response data of the same structure according to the structure of the response data\r\n   // For example, when creating a Todo item, the id of this piece of data will be returned.\r\n   silentDefaultResponse: () => {\r\n     return {\r\n       id: '--'\r\n     };\r\n   }\r\n   // highlight-end\r\n});\r\n// highlight-start\r\nonSuccess(({ data, silentMethod }) => {\r\n   // Construct list data items\r\n   const editingItem = {\r\n     ...detail,\r\n\r\n     // When editing, use the original id, otherwise use the id in the response data\r\n     // When submitting silently, data.id is virtual data, and when in static behavior mode, data.id is the actual id value\r\n     id: id || data.id\r\n   };\r\n\r\n   const method TodoList = todoList();\r\n   setCache(methodTodoList, todoListRaw => {\r\n     if (id) {\r\n       todoListRaw = todoListRaw.map(item => (equals(item.id, id) ? editingItem : item));\r\n     } else {\r\n       todoListRaw.unshift(editingItem);\r\n     }\r\n     return todoListRaw;\r\n   });\r\n   // Call setUpdateState to set response data tracking, so as to achieve the same delayed update effect as updateStateEffect\r\n   if (silentMethod) {\r\n     silentMethod.setUpdateState(methodTodoList);\r\n     silentMethod.save();\r\n   }\r\n});\r\n// highlight-end\n"})})]})]}),"\n",(0,a.jsx)(t.h3,{id:"update-list-after-removal",children:"Update list after removal"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"import { useSQRequest, updateStateEffect } from '@alova/scene-*';\r\nimport { deleteTodo, todoList } from './api.js';\r\n\r\nconst { loading, data, send, onSuccess } = useSQRequest(deleteTodo, {\r\n  immediate: false,\r\n  // highlight-start\r\n  behavior: 'silent'\r\n  // highlight-end\r\n});\r\n\r\nonSuccess(({ sendArgs: [deletingId] }) => {\r\n  updateStateEffect(todoList(), todoListRaw => todoListRaw.filter(item => item.id !== deletingId));\r\n});\r\n\r\n// Event callback triggers delete request\r\nconst handleDelete = deletingId => {\r\n  send(deletingId);\r\n};\n"})}),"\n",(0,a.jsx)(t.h2,{id:"save-the-operation-record",children:"Save the operation record"}),"\n",(0,a.jsx)(t.p,{children:"It is not enough to just update the list manually. We also need to consider that when the network is restored and there are still waiting requests in the request queue, the list data loaded at this time does not include the part of the unsubmitted request, which will cause certain problems for the user. Puzzled:"}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:'"I have clearly added multiple pieces of data, why is it not in the list?"'}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"Therefore, we need to record the operation and related data in the success callback, so that when the list data is loaded again, the uncommitted data will be manually compensated to the list, so that the list data will always be kept up-to-date."}),"\n",(0,a.jsx)(t.p,{children:"Saving operation records is also very simple, you only need to mount the relevant data to the silentMethod instance, and it will be persisted along with the instance."}),"\n",(0,a.jsx)(t.h3,{id:"createedit-success-callback",children:"create/edit success callback"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"//...\r\nonSuccess(({ silentMethod }) => {\r\n  // Construct list data items\r\n  const editingItem = {\r\n    ...detail,\r\n    id: id || data.id\r\n  };\r\n  //...\r\n  // highlight-start\r\n  if (silentMethod) {\r\n    // Set the name for subsequent queries\r\n    // If editingItem.id is virtual data will be automatically converted to its id\r\n    silentMethod.entity.setName('edit' + editingItem.id);\r\n    silentMethod.reviewData = {\r\n      operate: id ? 'edit' : 'add',\r\n      data: editingItem\r\n    };\r\n    silentMethod.save();\r\n  }\r\n  // highlight-end\r\n});\n"})}),"\n",(0,a.jsx)(t.h3,{id:"delete-success-callback",children:"delete success callback"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"//...\r\nonSuccess(({ sendArgs: [deletingId], silentMethod }) => {\r\n  //...\r\n  // highlight-start\r\n  if (silentMethod) {\r\n    silentMethod.reviewData = {\r\n      operate: 'delete',\r\n      data: {\r\n        id: deletingId\r\n      }\r\n    };\r\n    silentMethod.save();\r\n  }\r\n  // highlight-end\r\n});\n"})}),"\n",(0,a.jsx)(t.h3,{id:"precautions",children:"Precautions"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:["In the onSuccess callback function, silentMethod has a value only in the ",(0,a.jsx)(t.code,{children:"queue"})," and ",(0,a.jsx)(t.code,{children:"silent"})," behavior modes;"]}),"\n",(0,a.jsxs)(t.li,{children:["Generally speaking, you can use ",(0,a.jsx)(t.code,{children:"silentMethod.a = ..."})," or ",(0,a.jsx)(t.code,{children:"silentMethod.b = ..."})," to save operation records, but it will report an error in typescript, so ",(0,a.jsx)(t.em,{children:"reviewData"})," is specially provided as a silent Submit the save attribute of the operation record;"]}),"\n",(0,a.jsxs)(t.li,{children:["After modifying the silentMethod data, you need to save the modification through ",(0,a.jsx)(t.code,{children:"silentMethod.save()"}),";"]}),"\n"]}),"\n",(0,a.jsx)(t.p,{children:"The next step is to set retry parameters on silent submit requests."})]})}function p(e={}){const{wrapper:t}={...(0,r.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(h,{...e})}):h(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>s});n(7294);var a=n(4334);const r={tabItem:"tabItem_Ymn6"};var i=n(5893);function s(e){let{children:t,hidden:n,className:s}=e;return(0,i.jsx)("div",{role:"tabpanel",className:(0,a.Z)(r.tabItem,s),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>y});var a=n(7294),r=n(4334),i=n(2466),s=n(6550),o=n(469),l=n(1980),d=n(7392),c=n(12);function u(e){return a.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,a.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function h(e){const{values:t,children:n}=e;return(0,a.useMemo)((()=>{const e=t??function(e){return u(e).map((e=>{let{props:{value:t,label:n,attributes:a,default:r}}=e;return{value:t,label:n,attributes:a,default:r}}))}(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function m(e){let{queryString:t=!1,groupId:n}=e;const r=(0,s.k6)(),i=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,l._X)(i),(0,a.useCallback)((e=>{if(!i)return;const t=new URLSearchParams(r.location.search);t.set(i,e),r.replace({...r.location,search:t.toString()})}),[i,r])]}function g(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,i=h(e),[s,l]=(0,a.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const a=n.find((e=>e.default))??n[0];if(!a)throw new Error("Unexpected error: 0 tabValues");return a.value}({defaultValue:t,tabValues:i}))),[d,u]=m({queryString:n,groupId:r}),[g,f]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,i]=(0,c.Nk)(n);return[r,(0,a.useCallback)((e=>{n&&i.set(e)}),[n,i])]}({groupId:r}),v=(()=>{const e=d??g;return p({value:e,tabValues:i})?e:null})();(0,o.Z)((()=>{v&&l(v)}),[v]);return{selectedValue:s,selectValue:(0,a.useCallback)((e=>{if(!p({value:e,tabValues:i}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),f(e)}),[u,f,i]),tabValues:i}}var f=n(2389);const v={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(5893);function j(e){let{className:t,block:n,selectedValue:a,selectValue:s,tabValues:o}=e;const l=[],{blockElementScrollPositionUntilNextRender:d}=(0,i.o5)(),c=e=>{const t=e.currentTarget,n=l.indexOf(t),r=o[n].value;r!==a&&(d(t),s(r))},u=e=>{let t=null;switch(e.key){case"Enter":c(e);break;case"ArrowRight":{const n=l.indexOf(e.currentTarget)+1;t=l[n]??l[0];break}case"ArrowLeft":{const n=l.indexOf(e.currentTarget)-1;t=l[n]??l[l.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,r.Z)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:i}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:a===t?0:-1,"aria-selected":a===t,ref:e=>l.push(e),onKeyDown:u,onClick:c,...i,className:(0,r.Z)("tabs__item",v.tabItem,i?.className,{"tabs__item--active":a===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:r}=e;const i=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=i.find((e=>e.props.value===r));return e?(0,a.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:i.map(((e,t)=>(0,a.cloneElement)(e,{key:t,hidden:e.props.value!==r})))})}function w(e){const t=g(e);return(0,b.jsxs)("div",{className:(0,r.Z)("tabs-container",v.tabList),children:[(0,b.jsx)(j,{...e,...t}),(0,b.jsx)(x,{...e,...t})]})}function y(e){const t=(0,f.Z)();return(0,b.jsx)(w,{...e,children:u(e.children)},String(t))}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>s});var a=n(7294);const r={},i=a.createContext(r);function s(e){const t=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:t},e.children)}}}]);