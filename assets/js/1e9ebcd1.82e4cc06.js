"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[8298],{4518:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(5893),a=n(1151);const o={title:"Method Metadata",sidebar_position:60},s=void 0,i={id:"tutorial/getting-started/method-metadata",title:"Method Metadata",description:"v2.7.0+",source:"@site/docs/tutorial/02-getting-started/06-method-metadata.md",sourceDirName:"tutorial/02-getting-started",slug:"/tutorial/getting-started/method-metadata",permalink:"/tutorial/getting-started/method-metadata",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/02-getting-started/06-method-metadata.md",tags:[],version:"current",sidebarPosition:60,frontMatter:{title:"Method Metadata",sidebar_position:60},sidebar:"tutorialSidebar",previous:{title:"Global Interceptor",permalink:"/tutorial/getting-started/global-interceptor"},next:{title:"Combine Framework",permalink:"/tutorial/combine-framework/"}},d={},c=[{value:"Use metadata to identify identities",id:"use-metadata-to-identify-identities",level:2},{value:"Use identity before request",id:"use-identity-before-request",level:3},{value:"Use the identity after the response",id:"use-the-identity-after-the-response",level:3},{value:"Use metadata to pass information",id:"use-metadata-to-pass-information",level:2},{value:"Tips for non-typescript projects",id:"tips-for-non-typescript-projects",level:2}];function l(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.admonition,{title:"version requirements",type:"info",children:(0,r.jsx)(t.p,{children:"v2.7.0+"})}),"\n",(0,r.jsx)(t.p,{children:"Method instances run through the entire request life cycle of alova, and there will be a large number of different method instances in the project. Sometimes we need to add additional information to specific method instances to facilitate their identification or additional information transfer. Wait, at this point, we need to use method metadata."}),"\n",(0,r.jsx)(t.h2,{id:"use-metadata-to-identify-identities",children:"Use metadata to identify identities"}),"\n",(0,r.jsx)(t.h3,{id:"use-identity-before-request",children:"Use identity before request"}),"\n",(0,r.jsxs)(t.p,{children:["For example, most of the interfaces in your project need to be accompanied by ",(0,r.jsx)(t.code,{children:"token"})," for each request, but there are still some interfaces that do not require verification. You may handle them uniformly in the global ",(0,r.jsx)(t.code,{children:"beforeRequest"})," function."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const nonvalidateRequiredApi = [\r\n  '/api/url1',\r\n  '/api/url2',\r\n  '/api/url3'\r\n  // ...\r\n];\r\n\r\ncreateAlova({\r\n  beforeRequest(method) {\r\n    if (!nonvalidateRequiredApi.includes(method.url)) {\r\n      method.config.headers.token = '...';\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.p,{children:"This will cause the following two problems:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Information is not aggregated with method instances, making maintainability even worse;"}),"\n",(0,r.jsx)(t.li,{children:"Coding is more troublesome;"}),"\n"]}),"\n",(0,r.jsx)(t.p,{children:"To solve these two problems, we will use metadata to identify a specific method instance when it is created."}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Step 1: Define metadata when creating method instance"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const loginAPI = (username, password) => {\r\n  const methodInstance = alovaInst.Post('/login', {\r\n    username,\r\n    password\r\n  });\r\n  methodInstance.meta = {\r\n    ignoreToken: true\r\n  };\r\n  return methodInstance;\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Step 2: Use metadata as the basis for judgment in ",(0,r.jsx)(t.code,{children:"beforeRequest"})]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"createAlova({\r\n  // ...\r\n  beforeRequest(method) {\r\n    if (!method.meta?.ignoreToken) {\r\n      method.config.headers.token = '...';\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.h3,{id:"use-the-identity-after-the-response",children:"Use the identity after the response"}),"\n",(0,r.jsxs)(t.p,{children:["This method can also be used in global ",(0,r.jsx)(t.code,{children:"responded"}),". For example, in most cases, the request api will return json data, but there may be a file download interface, which will return a binary data stream. In this case Below, you can use different metadata in ",(0,r.jsx)(t.code,{children:"responded"})," to handle different responses separately."]}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.strong,{children:"Step one: When creating a method instance, you also need to assign a metadata"})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const downloadAPI = filePath => {\r\n  const methodInstance = alovaInst.Post('/download_file', {\r\n    filePath\r\n  });\r\n  methodInstance.meta = {\r\n    isDownload: true\r\n  };\r\n  return methodInstance;\r\n};\n"})}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsxs)(t.strong,{children:["Step 2: Use metadata in ",(0,r.jsx)(t.code,{children:"responded"})," as a basis for judgment"]})}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"createAlova({\r\n   // ...\r\n   responded:\r\n     onSuccess: (response, method) => method.meta?.isDownload ? response.blob() : response.json()\r\n     onError: (error, method) => {\r\n       //Metadata of method instances can also be accessed when responding to errors\r\n     }\r\n   }\r\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"use-metadata-to-pass-information",children:"Use metadata to pass information"}),"\n",(0,r.jsx)(t.p,{children:"In some cases, if you want to add additional information to different method instances for use elsewhere, you can also use metadata to save it. Take uniformly generating different method instance IDs as an example."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"createAlova({\r\n  beforeRequest(method) {\r\n    if (!method.meta.generateId) {\r\n      method.meta.uid = generateUUID();\r\n    }\r\n  },\r\n\r\n  responded: {\r\n    onSuccess(response, method) {\r\n      // Access the meta data generated by the current method when the request is successful.\r\n      const currentMethodUID = method.meta.uid;\r\n    },\r\n    onError(error, method) {\r\n      //Access the meta data generated by the current method when the request fails.\r\n      const currentMethodUID = method.meta.uid;\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"tips-for-non-typescript-projects",children:"Tips for non-typescript projects"}),"\n",(0,r.jsxs)(t.p,{children:["In a non-typescript environment, you can use any attribute as an information carrier, not limited to the ",(0,r.jsx)(t.code,{children:"meta"})," attribute."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"methodInstance.showResponseMsg = true;\r\nmethodInstance.others = 'abc';\n"})}),"\n",(0,r.jsxs)(t.p,{children:['Only in the typescript environment, any attribute name will report that the attribute "$0" does not exist. ts(2339)',(0,r.jsx)(t.code,{children:", so in the type we specify the "}),"meta` attribute as the information carrier."]})]})}function h(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var r=n(7294);const a={},o=r.createContext(a);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);