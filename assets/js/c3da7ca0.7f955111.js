"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[8934],{2349:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>f,frontMatter:()=>o,metadata:()=>d,toc:()=>h});var r=n(5893),s=n(1151),a=n(4866),i=n(5162);const o={title:"Data fetch",sidebar_position:50},c=void 0,d={id:"tutorial/learning/use-fetcher",title:"Data fetch",description:"When you have the following needs:",source:"@site/docs/tutorial/03-learning/05-use-fetcher.md",sourceDirName:"tutorial/03-learning",slug:"/tutorial/learning/use-fetcher",permalink:"/tutorial/learning/use-fetcher",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/03-learning/05-use-fetcher.md",tags:[],version:"current",sidebarPosition:50,frontMatter:{title:"Data fetch",sidebar_position:50},sidebar:"tutorialSidebar",previous:{title:"Request when states Changed",permalink:"/tutorial/learning/use-watcher"},next:{title:"Cache mode",permalink:"/tutorial/learning/response-cache"}},l={},h=[{value:"Update views across modules/components",id:"update-views-across-modulescomponents",level:2},{value:"preload data",id:"preload-data",level:2},{value:"Force send request",id:"force-send-request",level:2},{value:"Set static value",id:"set-static-value",level:3},{value:"Dynamically set the force value",id:"dynamically-set-the-force-value",level:3},{value:"fetch function parameter passing rules",id:"fetch-function-parameter-passing-rules",level:2},{value:"Received in onSuccess, onError, onComplete callback functions",id:"received-in-onsuccess-onerror-oncomplete-callback-functions",level:3},{value:"Received in the force function",id:"received-in-the-force-function",level:3},{value:"Compare with useRequest and useWatcher",id:"compare-with-userequest-and-usewatcher",level:2},{value:"API",id:"api",level:2},{value:"Hook configuration",id:"hook-configuration",level:3},{value:"AlovaFetcherMiddlewareContext",id:"alovafetchermiddlewarecontext",level:3},{value:"FetchRequestState",id:"fetchrequeststate",level:4},{value:"Responsive data",id:"responsive-data",level:3},{value:"Action function",id:"action-function",level:3},{value:"Event",id:"event",level:3}];function u(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"When you have the following needs:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Preload the data that will be used in the subsequent process and store it in the cache, so that users no longer wait for the data loading process;"}),"\n",(0,r.jsx)(t.li,{children:"It is convenient to update data across pages (similar to the global state), for example, after modifying an item in the todo list and re-fetching the latest data, the interface will be refreshed after the response."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"useFetcher"})," is the hook used to implement the above scenarios. The response data obtained through it cannot be received directly, but the data fetched through it will not only update the cache, but also update the corresponding state, thereby re-rendering the view."]}),"\n",(0,r.jsx)(t.p,{children:"You can use it to pre-fetch data and save it in the cache, or gracefully update the state across components, such as modifying an item in the todo list and re-fetching the latest data, and the interface will be refreshed after the response"}),"\n",(0,r.jsx)(t.h2,{id:"update-views-across-modulescomponents",children:"Update views across modules/components"}),"\n",(0,r.jsx)(t.p,{children:"Next, let's modify a certain todo data, and re-fetch the latest todo list data to update the view."}),"\n",(0,r.jsxs)(a.Z,{groupId:"framework",children:[(0,r.jsx)(i.Z,{value:"1",label:"vue composition",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- Render the unified fetch state. --\x3e\r\n  <div v-if=\"fetching\">{{ Fetching data in background... }}</div>\r\n\r\n  \x3c!-- ... --\x3e\r\n  <button @click=\"handleSubmit\">Modify todo items</button>\r\n</template>\r\n\r\n<script setup>\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      // Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\r\n      // For details, see the subsequent \"Method Instance Matcher\" chapter\r\n      name: 'todoList',\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const {\r\n    // The fetching attribute is the same as loading, it is true when a fetch request is sent, and it is false after the request ends\r\n    fetching,\r\n    error,\r\n    onSuccess,\r\n    onError,\r\n    onComplete,\r\n\r\n    // After calling fetch, a request to fetch data will be sent, and fetch can be called repeatedly to fetch data from different interfaces\r\n    fetch\r\n  } = useFetcher();\r\n\r\n  // Trigger the data fetch in the event\r\n  const handleSubmit = () => {\r\n    // todo item modification...\r\n\r\n    // Start to fetch the updated data\r\n    // Situation 1: When you clearly know that the data on the first page of todoList is fetched, pass in a Method instance\r\n    fetch(getTodoList(1));\r\n\r\n    // Situation 2: When you only know to fetch the last requested data of todoList, use the Method instance matcher to filter\r\n    fetch({\r\n      name: 'todoList',\r\n      filter: (method, index, ary) => {\r\n        // Return true to specify the Method instance that needs to be fetched\r\n        return index === ary.length - 1;\r\n      }\r\n    });\r\n  };\r\n<\/script>\n"})})}),(0,r.jsx)(i.Z,{value:"2",label:"react",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"const getTodoList = currentPage => {\r\n  return alovaInstance.Get('/todo/list', {\r\n    // Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\r\n    // For details, see the subsequent \"Method Instance Matcher\" chapter\r\n    name: 'todoList',\r\n    params: {\r\n      currentPage,\r\n      pageSize: 10\r\n    }\r\n  });\r\n};\r\n\r\nconst App = () => {\r\n  const {\r\n    // The fetching attribute is the same as loading, it is true when a fetch request is sent, and it is false after the request ends\r\n    fetching,\r\n    error,\r\n    onSuccess,\r\n    onError,\r\n    onComplete,\r\n\r\n    // After calling fetch, a request to fetch data will be sent, and fetch can be called repeatedly to fetch data from different interfaces\r\n    fetch\r\n  } = useFetcher();\r\n\r\n  // Trigger the data fetch in the event\r\n  const handleSubmit = () => {\r\n    // Assume the modification of the todo item has been completed...\r\n\r\n    // Start to fetch the updated data\r\n    // Situation 1: When you clearly know that the data on the first page of todoList is fetched, pass in a Method instance\r\n    fetch(getTodoList(1));\r\n\r\n    // Situation 2: When you only know to fetch the last requested data of todoList, use the Method instance matcher to filter\r\n    fetch({\r\n      name: 'todoList',\r\n      filter: (method, index, ary) => {\r\n        // Return true to specify the Method instance that needs to be fetched\r\n        return index === ary.length - 1;\r\n      }\r\n    });\r\n  };\r\n\r\n  return (\r\n    <>\r\n      {/* Render the unified fetch state */}\r\n      {fetching ? <div>Fetching data in the background...</div> : null}\r\n      {/* ... */}\r\n      <button onClick={handleSubmit}>Modify todo items</button>\r\n    </>\r\n  );\r\n};\n"})})}),(0,r.jsx)(i.Z,{value:"3",label:"svelte",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<script>\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      // Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\r\n      // For details, see the subsequent \"Method Instance Matcher\" chapter\r\n      name: 'todoList',\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const {\r\n    // The fetching attribute is the same as loading, it is true when a fetch request is sent, and it is false after the request ends\r\n    fetching,\r\n    error,\r\n    onSuccess,\r\n    onError,\r\n    onComplete,\r\n\r\n    // After calling fetch, a request to fetch data will be sent, and fetch can be called repeatedly to fetch data from different interfaces\r\n    fetch\r\n  } = useFetcher();\r\n\r\n  // Trigger the data fetch in the event\r\n  const handleSubmit = () => {\r\n    // Assume the modification of the todo item has been completed...\r\n\r\n    // Start to fetch the updated data\r\n    // Situation 1: When you clearly know that the data on the first page of todoList is fetched, pass in a Method instance\r\n    fetch(getTodoList(1));\r\n\r\n    // Situation 2: When you only know to fetch the last requested data of todoList, use the Method instance matcher to filter\r\n    fetch({\r\n      name: 'todoList',\r\n      filter: (method, index, ary) => {\r\n        // Return true to specify the Method instance that needs to be fetched\r\n        return index === ary.length - 1;\r\n      }\r\n    });\r\n  };\r\n<\/script>\r\n\r\n\x3c!-- Render a unified fetch state --\x3e\r\n{#if $fetching}\r\n<div>{{ fetching data in background... }}</div>\r\n{/if}\r\n\x3c!-- ... --\x3e\r\n<button on:click=\"{handleSubmit}\">Modify todo items</button>\n"})})}),(0,r.jsx)(i.Z,{value:"4",label:"vue options",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- Render a unified fetch state --\x3e\r\n  <div v-if=\"fetcher.fetching\">{{ fetching data in background... }}</div>\r\n\r\n  \x3c!-- ... --\x3e\r\n  <button @click=\"handleSubmit\">Modify todo items</button>\r\n</template>\r\n\r\n<script>\r\n  import { mapAlovaHook } from '@alova/vue-options';\r\n  import { useFetcher } from 'alova';\r\n\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      // Note: The name attribute is set here to filter out the required Method instance when the Method instance cannot be specified directly\r\n      // For details, see the subsequent \"Method Instance Matcher\" chapter\r\n      name: 'todoList',\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  export default {\r\n    mixins: mapAlovaHook(function () {\r\n      const {\r\n        // The fetching attribute is the same as loading, it is true when a fetch request is sent, and it is false after the request ends\r\n        fetching,\r\n        error,\r\n        onSuccess,\r\n        onError,\r\n        onComplete,\r\n\r\n        // After calling fetch, a request to fetch data will be sent, and fetch can be called repeatedly to fetch data from different interfaces\r\n        fetch\r\n      } = (fetcherStates = useFetcher());\r\n      return {\r\n        fetcher: fetcherStates\r\n      };\r\n    }),\r\n    methods: {\r\n      // Trigger the data fetch in the event\r\n      handleSubmit() {\r\n        // Assume the modification of the todo item has been completed...\r\n\r\n        // Start to fetch the updated data\r\n        // Situation 1: When you clearly know that the data on the first page of todoList is fetched, pass in a Method instance\r\n        this.fetcher$fetch(getTodoList(1));\r\n\r\n        // Situation 2: When you only know to fetch the last requested data of todoList, use the Method instance matcher to filter\r\n        this.fetcher$fetch({\r\n          name: 'todoList',\r\n          filter: (method, index, ary) => {\r\n            // Return true to specify the Method instance that needs to be fetched\r\n            return index === ary.length - 1;\r\n          }\r\n        });\r\n      }\r\n    }\r\n  };\r\n<\/script>\n"})})})]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["See ",(0,r.jsx)(t.a,{href:"/tutorial/next-step/method-instance-matcher",children:"Method instance matcher"})," for more usage methods of ",(0,r.jsx)(t.code,{children:"Method"})," instance matcher"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"preload-data",children:"preload data"}),"\n",(0,r.jsx)(t.p,{children:"The following implements the preloading function of the next page of data in the paging scenario of the todo list."}),"\n",(0,r.jsxs)(a.Z,{groupId:"framework",children:[(0,r.jsx)(i.Z,{value:"1",label:"vue composition",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- ... --\x3e\r\n</template>\r\n\r\n<script setup>\r\n  // method instance creation function\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const { fetch } = useFetcher();\r\n\r\n  const currentPage = ref(1);\r\n  const { data, onSuccess } = useWatcher(() => getTodoList(currentPage.value), [currentPage], {\r\n    immediate: true\r\n  });\r\n\r\n  // Pre-fetch the data of the next page when the current page request is successful\r\n  // Realize that there is no need to wait for the request when turning the page to the next page\r\n  onSuccess(() => {\r\n    fetch(getTodoList(currentPage.value + 1));\r\n  });\r\n<\/script>\n"})})}),(0,r.jsx)(i.Z,{value:"2",label:"react",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"import { useState } from 'react';\r\n\r\n// method instance creation function\r\nconst getTodoList = currentPage => {\r\n  return alovaInstance.Get('/todo/list', {\r\n    params: {\r\n      currentPage,\r\n      pageSize: 10\r\n    }\r\n  });\r\n};\r\n\r\nconst App = () => {\r\n  const { fetch } = useFetcher();\r\n  const [currentPage, setCurrentPage] = useState(1);\r\n  const { data, onSuccess } = useWatcher(() => getTodoList(currentPage), [currentPage], {\r\n    immediate: true\r\n  });\r\n\r\n  // Pre-fetch the data of the next page when the current page request is successful\r\n  // Realize that there is no need to wait for the request when turning the page to the next page\r\n  onSuccess(() => {\r\n    fetch(getTodoList(currentPage + 1));\r\n  });\r\n\r\n  return {\r\n    /* ... */\r\n  };\r\n};\n"})})}),(0,r.jsx)(i.Z,{value:"3",label:"svelte",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<script>\r\n  import { writable } from 'svelte/store';\r\n\r\n  // method instance creation function\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const { fetch } = useFetcher();\r\n  const currentPage = writable(1);\r\n  const { data, onSuccess } = useWatcher(() => getTodoList($currentPage), [currentPage], {\r\n    immediate: true\r\n  });\r\n\r\n  // Pre-fetch the data of the next page when the current page request is successful\r\n  // Realize that there is no need to wait for the request when turning the page to the next page\r\n  onSuccess(() => {\r\n    fetch(getTodoList($currentPage + 1));\r\n  });\r\n<\/script>\r\n\r\n\x3c!-- views... --\x3e\n"})})}),(0,r.jsx)(i.Z,{value:"4",label:"vue options",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- ... --\x3e\r\n</template>\r\n\r\n<script>\r\n  import { mapAlovaHook } from '@alova/vue-options';\r\n  import { useFetcher, useWatcher } from 'alova';\r\n\r\n  // method instance creation function\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  export default {\r\n    mixins: mapAlovaHook(function () {\r\n      return {\r\n        fetcher: useFetcher(),\r\n        paging: useWatcher(() => getTodoList(this.currentPage), ['currentPage'], {\r\n          immediate: true\r\n        })\r\n      };\r\n    }),\r\n    data() {\r\n      return {\r\n        currentPage: 1\r\n      };\r\n    },\r\n    mounted() {\r\n      // Pre-fetch the data of the next page when the current page request is successful\r\n      // Realize that there is no need to wait for the request when turning the page to the next page\r\n      this.paging$onSuccess(() => {\r\n        this.fetcher$fetch(getTodoList(this.currentPage + 1));\r\n      });\r\n    }\r\n  };\r\n<\/script>\n"})})})]}),"\n",(0,r.jsx)(t.admonition,{title:"Notes",type:"warning",children:(0,r.jsxs)(t.p,{children:["After the useFetcher request is completed, only the cache is updated, and if it is found that there is still a ",(0,r.jsx)(t.code,{children:"data"})," state under the ",(0,r.jsx)(t.code,{children:"Method"})," instance, it will also be updated synchronously, so as to ensure that the page data is consistent. This is ",(0,r.jsx)(t.code,{children:"useFetcher"})," used to update views across modules/components ensure."]})}),"\n",(0,r.jsx)(t.h2,{id:"force-send-request",children:"Force send request"}),"\n",(0,r.jsxs)(t.p,{children:["Same as ",(0,r.jsx)(t.code,{children:"useRequest"})," and ",(0,r.jsx)(t.code,{children:"useWatcher"}),", you can specify ",(0,r.jsx)(t.code,{children:"force"})," parameter in ",(0,r.jsx)(t.code,{children:"useFetcher"})," to set whether to send the request."]}),"\n",(0,r.jsx)(t.h3,{id:"set-static-value",children:"Set static value"}),"\n",(0,r.jsx)(t.p,{children:"force is false by default. When set to true, the cache will be penetrated every time and a request will be sent"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"useFetcher({ force: true });\n"})}),"\n",(0,r.jsx)(t.h3,{id:"dynamically-set-the-force-value",children:"Dynamically set the force value"}),"\n",(0,r.jsx)(t.p,{children:"In actual situations, we often need to set whether to force the request to be sent according to different situations. At this time, force can be set as a function, which can be passed in through the fetch function."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"useFetcher({\r\n  force: isForce => {\r\n    return isForce;\r\n  }\r\n});\n"})}),"\n",(0,r.jsx)(t.h2,{id:"fetch-function-parameter-passing-rules",children:"fetch function parameter passing rules"}),"\n",(0,r.jsx)(t.p,{children:"In the above example, the fetch function is called to trigger data fetching. The fetch function can also pass in custom parameters starting from the second parameter, and these parameters will be received by the following four functions:"}),"\n",(0,r.jsx)(t.h3,{id:"received-in-onsuccess-onerror-oncomplete-callback-functions",children:"Received in onSuccess, onError, onComplete callback functions"}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"event.sendArgs"})," in onSuccess, onError, and onComplete callback functions are received in the form of an array"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const { fetch, onSuccess, onError, onComplete } = useFetcher();\r\nonSuccess(event => {\r\n  // The value of sendArgs is ['a', 'b']\r\n  console.log(event.sendArgs);\r\n});\r\nonError(event => {\r\n  // The value of sendArgs is ['a', 'b']\r\n  console.log(event.sendArgs);\r\n});\r\nonComplete(event => {\r\n  // The value of sendArgs is ['a', 'b']\r\n  console.log(event.sendArgs);\r\n});\r\n\r\n// fetch data\r\nfetch(getTodoList(10), 'a', 'b');\n"})}),"\n",(0,r.jsx)(t.h3,{id:"received-in-the-force-function",children:"Received in the force function"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-javascript",children:"const { fetch } = useFetcher({\r\n  force: isForce => {\r\n    // The value of isForce is true\r\n    return isForce;\r\n  }\r\n});\r\nfetch(getTodoList(10), true);\n"})}),"\n",(0,r.jsx)(t.h2,{id:"compare-with-userequest-and-usewatcher",children:"Compare with useRequest and useWatcher"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["useFetcher does not return the ",(0,r.jsx)(t.code,{children:"data"})," field, the pre-fetched data will be saved in the cache, and the status data of the corresponding location will be updated;"]}),"\n",(0,r.jsxs)(t.li,{children:["Rename ",(0,r.jsx)(t.code,{children:"loading"})," to ",(0,r.jsx)(t.code,{children:"fetching"}),";"]}),"\n",(0,r.jsxs)(t.li,{children:["There is no ",(0,r.jsx)(t.code,{children:"send"})," function, but there is a ",(0,r.jsx)(t.code,{children:"fetch"})," function, which can be reused to fetch data from different interfaces. At this time, you can use the ",(0,r.jsx)(t.code,{children:"fetching"})," and ",(0,r.jsx)(t.code,{children:"error"})," states to render views uniformly, so as to achieve unified processing the goal of;"]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"api",children:"API"}),"\n",(0,r.jsx)(t.h3,{id:"hook-configuration",children:"Hook configuration"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Default"}),(0,r.jsx)(t.th,{children:"Version"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"force"}),(0,r.jsx)(t.td,{children:"Whether to force the request, it can be set as a function to dynamically return a boolean value"}),(0,r.jsx)(t.td,{children:"boolean"}),(0,r.jsx)(t.td,{children:"(...args: any[]) => boolean | false"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"middleware"}),(0,r.jsxs)(t.td,{children:["Middleware function, ",(0,r.jsx)(t.a,{href:"/tutorial/advanced/middleware",children:"Learn about alova middleware"})]}),(0,r.jsxs)(t.td,{children:["(context: ",(0,r.jsx)(t.a,{href:"#alovafetchermiddlewarecontext",children:"AlovaFetcherMiddlewareContext"}),", next: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovaguardnext",children:"AlovaGuardNext"}),") => Promise<any>"]}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"-"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"alovafetchermiddlewarecontext",children:"AlovaFetcherMiddlewareContext"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Version"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"method"}),(0,r.jsx)(t.td,{children:"The method object of the current request"}),(0,r.jsx)(t.td,{children:"Method"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"cachedResponse"}),(0,r.jsx)(t.td,{children:"hit cached data"}),(0,r.jsx)(t.td,{children:"any"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"config"}),(0,r.jsx)(t.td,{children:"current use hook configuration"}),(0,r.jsx)(t.td,{children:"Record<string, any>"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetchArgs"}),(0,r.jsx)(t.td,{children:"The parameters of the response processing callback, which are passed in by the fetch of useFetcher"}),(0,r.jsx)(t.td,{children:"any[]"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetchStates"}),(0,r.jsx)(t.td,{children:"use hook preload state collection, such as fetching, error, etc."}),(0,r.jsx)(t.td,{children:(0,r.jsx)(t.a,{href:"#fetchrequeststate",children:"FetchRequestState"})}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetch"}),(0,r.jsx)(t.td,{children:"data preloading function"}),(0,r.jsx)(t.td,{children:"(method: Method, ...args: any[]) => void"}),(0,r.jsx)(t.td,{children:"Promise"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"abort"}),(0,r.jsx)(t.td,{children:"interrupt function"}),(0,r.jsx)(t.td,{children:"() => void"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"decorateSuccess"}),(0,r.jsx)(t.td,{children:"Decorate success callback function"}),(0,r.jsxs)(t.td,{children:["(decorator: (",(0,r.jsx)("br",{}),"handler: (event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovasuccessevent",children:"AlovaSuccessEvent"}),") => void, ",(0,r.jsx)("br",{}),"event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovasuccessevent",children:"AlovaSuccessEvent"}),", ",(0,r.jsx)("br",{}),"index: number, ",(0,r.jsx)("br",{}),"length: number",(0,r.jsx)("br",{}),") => void) => void"]}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"decorateError"}),(0,r.jsx)(t.td,{children:"Decoration failure callback function"}),(0,r.jsxs)(t.td,{children:["(decorator: (",(0,r.jsx)("br",{}),"handler: (event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovaerrorevent",children:"AlovaErrorEvent"})," => void, ",(0,r.jsx)("br",{}),"event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovaerrorevent",children:"AlovaErrorEvent"}),", ",(0,r.jsx)("br",{}),"index: number, ",(0,r.jsx)("br",{}),"length: number",(0,r.jsx)("br",{}),") => void) => void"]}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"decorateComplete"}),(0,r.jsx)(t.td,{children:"Decoration completion callback function"}),(0,r.jsxs)(t.td,{children:["(decorator: (",(0,r.jsx)("br",{}),"handler: (event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovacompleteevent",children:"AlovaCompleteEvent"}),") => void, ",(0,r.jsx)("br",{}),"event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovacompleteevent",children:"AlovaCompleteEvent"}),", ",(0,r.jsx)("br",{}),"index: number, ",(0,r.jsx)("br",{}),"length: number",(0,r.jsx)("br",{}),") => void) => void"]}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"update"}),(0,r.jsx)(t.td,{children:"A function to update the preloaded state of the current use hook, more useful in react"}),(0,r.jsxs)(t.td,{children:["(newFrontStates: ",(0,r.jsx)(t.a,{href:"#fetchrequeststate",children:"FetchRequestState"}),") => void;"]}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"controlFetching"}),(0,r.jsx)(t.td,{children:"After calling, it will control the state of fetching by itself, and the change of fetching state will no longer be triggered internally. When the passed in control is false, the control will be canceled"}),(0,r.jsx)(t.td,{children:"(control?: boolean) => void"}),(0,r.jsx)(t.td,{children:"-"})]})]})]}),"\n",(0,r.jsx)(t.h4,{id:"fetchrequeststate",children:"FetchRequestState"}),"\n",(0,r.jsxs)(t.p,{children:["The following attribute values will automatically infer the responsive data type corresponding to the UI framework according to ",(0,r.jsx)(t.code,{children:"statesHook"}),", which is ",(0,r.jsx)(t.code,{children:"Ref"})," type in vue3, normal value in react, and ",(0,r.jsx)(t.code,{children:"Writable"})," type in svelte"]}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Version"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetching"}),(0,r.jsx)(t.td,{children:"preload request status"}),(0,r.jsx)(t.td,{children:"boolean"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"error"}),(0,r.jsx)(t.td,{children:"request error message"}),(0,r.jsx)(t.td,{children:"Error | undefined"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"downloading"}),(0,r.jsx)(t.td,{children:"download progress information"}),(0,r.jsx)(t.td,{children:"Object"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"uploading"}),(0,r.jsx)(t.td,{children:"upload progress information"}),(0,r.jsx)(t.td,{children:"Object"}),(0,r.jsx)(t.td,{children:"-"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"responsive-data",children:"Responsive data"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Type"}),(0,r.jsx)(t.th,{children:"Version"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetching"}),(0,r.jsx)(t.td,{children:"preload request status"}),(0,r.jsx)(t.td,{children:"boolean"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"error"}),(0,r.jsx)(t.td,{children:"request error message"}),(0,r.jsx)(t.td,{children:"Error | undefined"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"downloading"}),(0,r.jsx)(t.td,{children:"download progress information"}),(0,r.jsx)(t.td,{children:"Object"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"uploading"}),(0,r.jsx)(t.td,{children:"upload progress information"}),(0,r.jsx)(t.td,{children:"Object"}),(0,r.jsx)(t.td,{children:"-"})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"action-function",children:"Action function"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"name"}),(0,r.jsx)(t.th,{children:"description"}),(0,r.jsx)(t.th,{children:"function parameters"}),(0,r.jsx)(t.th,{children:"return value"}),(0,r.jsx)(t.th,{children:"version"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"fetch"}),(0,r.jsx)(t.td,{children:"data preloading function"}),(0,r.jsxs)(t.td,{children:["1. method: preloaded Method instance",(0,r.jsx)("br",{}),"2. ...args: any[]"]}),(0,r.jsx)(t.td,{children:"Promise"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"abort"}),(0,r.jsx)(t.td,{children:"interrupt function"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"update"}),(0,r.jsx)(t.td,{children:"A function to update the front-end state of the current use hook, more useful in react"}),(0,r.jsxs)(t.td,{children:["newFrontStates: ",(0,r.jsx)(t.a,{href:"#frontrequeststate",children:"FrontRequestState"})]}),(0,r.jsx)(t.td,{children:"-"}),(0,r.jsx)(t.td,{})]})]})]}),"\n",(0,r.jsx)(t.h3,{id:"event",children:"Event"}),"\n",(0,r.jsxs)(t.table,{children:[(0,r.jsx)(t.thead,{children:(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.th,{children:"Name"}),(0,r.jsx)(t.th,{children:"Description"}),(0,r.jsx)(t.th,{children:"Callback Parameters"}),(0,r.jsx)(t.th,{children:"Version"})]})}),(0,r.jsxs)(t.tbody,{children:[(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"onSuccess"}),(0,r.jsx)(t.td,{children:"Request success event binding"}),(0,r.jsxs)(t.td,{children:["event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovacompleteevent",children:"AlovaSuccessEvent"}),") => void, ",(0,r.jsx)("br",{}),"event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovasuccessevent",children:"AlovaCompleteEvent"})]}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"onError"}),(0,r.jsx)(t.td,{children:"Request error event binding"}),(0,r.jsxs)(t.td,{children:["event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovacompleteevent",children:"AlovaErrorEvent"}),") => void, ",(0,r.jsx)("br",{}),"event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovaerrorevent",children:"AlovaCompleteEvent"})]}),(0,r.jsx)(t.td,{children:"-"})]}),(0,r.jsxs)(t.tr,{children:[(0,r.jsx)(t.td,{children:"onComplete"}),(0,r.jsx)(t.td,{children:"Request completion event binding"}),(0,r.jsxs)(t.td,{children:["event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovacompleteevent",children:"AlovaCompleteEvent"}),") => void, ",(0,r.jsx)("br",{}),"event: ",(0,r.jsx)(t.a,{href:"/tutorial/learning/use-request/#alovacompleteevent",children:"AlovaCompleteEvent"})]}),(0,r.jsx)(t.td,{children:"-"})]})]})]})]})}function f(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>i});n(7294);var r=n(4334);const s={tabItem:"tabItem_Ymn6"};var a=n(5893);function i(e){let{children:t,hidden:n,className:i}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,r.Z)(s.tabItem,i),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>y});var r=n(7294),s=n(4334),a=n(2466),i=n(6550),o=n(469),c=n(1980),d=n(7392),l=n(12);function h(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:s}}=e;return{value:t,label:n,attributes:r,default:s}}))}(n);return function(e){const t=(0,d.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function f(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function x(e){let{queryString:t=!1,groupId:n}=e;const s=(0,i.k6)(),a=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,c._X)(a),(0,r.useCallback)((e=>{if(!a)return;const t=new URLSearchParams(s.location.search);t.set(a,e),s.replace({...s.location,search:t.toString()})}),[a,s])]}function p(e){const{defaultValue:t,queryString:n=!1,groupId:s}=e,a=u(e),[i,c]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!f({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:a}))),[d,h]=x({queryString:n,groupId:s}),[p,j]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[s,a]=(0,l.Nk)(n);return[s,(0,r.useCallback)((e=>{n&&a.set(e)}),[n,a])]}({groupId:s}),m=(()=>{const e=d??p;return f({value:e,tabValues:a})?e:null})();(0,o.Z)((()=>{m&&c(m)}),[m]);return{selectedValue:i,selectValue:(0,r.useCallback)((e=>{if(!f({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),j(e)}),[h,j,a]),tabValues:a}}var j=n(2389);const m={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var g=n(5893);function v(e){let{className:t,block:n,selectedValue:r,selectValue:i,tabValues:o}=e;const c=[],{blockElementScrollPositionUntilNextRender:d}=(0,a.o5)(),l=e=>{const t=e.currentTarget,n=c.indexOf(t),s=o[n].value;s!==r&&(d(t),i(s))},h=e=>{let t=null;switch(e.key){case"Enter":l(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return(0,g.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,s.Z)("tabs",{"tabs--block":n},t),children:o.map((e=>{let{value:t,label:n,attributes:a}=e;return(0,g.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>c.push(e),onKeyDown:h,onClick:l,...a,className:(0,s.Z)("tabs__item",m.tabItem,a?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function b(e){let{lazy:t,children:n,selectedValue:s}=e;const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=a.find((e=>e.props.value===s));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,g.jsx)("div",{className:"margin-top--md",children:a.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==s})))})}function w(e){const t=p(e);return(0,g.jsxs)("div",{className:(0,s.Z)("tabs-container",m.tabList),children:[(0,g.jsx)(v,{...e,...t}),(0,g.jsx)(b,{...e,...t})]})}function y(e){const t=(0,j.Z)();return(0,g.jsx)(w,{...e,children:h(e.children)},String(t))}},1151:(e,t,n)=>{n.d(t,{Z:()=>o,a:()=>i});var r=n(7294);const s={},a=r.createContext(s);function i(e){const t=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),r.createElement(a.Provider,{value:t},e.children)}}}]);