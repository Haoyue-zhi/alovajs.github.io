"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[8532],{5347:(e,r,t)=>{t.r(r),t.d(r,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>d});var n=t(5893),s=t(1151);const a={title:"Step 3 - Set Request Retry",sidebar_position:60},i=void 0,o={id:"tutorial/strategy/sensorless-data-interaction/request-retry",title:"Step 3 - Set Request Retry",description:"When a request enters the silent queue, you can set request retry parameters for it to ensure its request success rate. This is valid when the behavior mode is set to queue and silent. The difference is, The request under the behavior of silent is persistent by default, and the request will continue to be sent even if it is refreshed before the request succeeds, while the request under the behavior of queue will not be persisted and will be cleared after refreshing.",source:"@site/docs/tutorial/06-strategy/01-sensorless-data-interaction/06-request-retry.md",sourceDirName:"tutorial/06-strategy/01-sensorless-data-interaction",slug:"/tutorial/strategy/sensorless-data-interaction/request-retry",permalink:"/tutorial/strategy/sensorless-data-interaction/request-retry",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/06-strategy/01-sensorless-data-interaction/06-request-retry.md",tags:[],version:"current",sidebarPosition:60,frontMatter:{title:"Step 3 - Set Request Retry",sidebar_position:60},sidebar:"tutorialSidebar",previous:{title:"Step 2 - Adjust Response Handling",permalink:"/tutorial/strategy/sensorless-data-interaction/modify-response"},next:{title:"Step 4 - Data Compensation",permalink:"/tutorial/strategy/sensorless-data-interaction/data-compensation"}},l={},d=[{value:"Maximum number of retries",id:"maximum-number-of-retries",level:2},{value:"Request delay time",id:"request-delay-time",level:2},{value:"set retry rules",id:"set-retry-rules",level:2}];function u(e){const r={code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsxs)(r.p,{children:["When a request enters the silent queue, you can set request retry parameters for it to ensure its request success rate. This is valid when the behavior mode is set to ",(0,n.jsx)(r.strong,{children:"queue"})," and ",(0,n.jsx)(r.strong,{children:"silent"}),". The difference is, The request under the behavior of ",(0,n.jsx)(r.strong,{children:"silent"})," is persistent by default, and the request will continue to be sent even if it is refreshed before the request succeeds, while the request under the behavior of ",(0,n.jsx)(r.strong,{children:"queue"})," will not be persisted and will be cleared after refreshing."]}),"\n",(0,n.jsx)(r.h2,{id:"maximum-number-of-retries",children:"Maximum number of retries"}),"\n",(0,n.jsx)(r.p,{children:"Set the maximum number of retries, no retries by default."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n  //...\r\n  // highlight-start\r\n  // The number of retries is 3 times\r\n  maxRetryTimes: 3\r\n  // highlight-end\r\n});\n"})}),"\n",(0,n.jsx)(r.h2,{id:"request-delay-time",children:"Request delay time"}),"\n",(0,n.jsx)(r.p,{children:"By default, each retry interval is 1000ms, and we can customize the delay time of each retry in the avoidance strategy."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n  //...\r\n  maxRetryTimes: 3,\r\n  // highlight-start\r\n  // Requests are delayed by 2000ms each time\r\n  backoff: {\r\n    delay: 2000\r\n  }\r\n  // highlight-end\r\n});\n"})}),"\n",(0,n.jsx)(r.p,{children:"If you need to increase the delay time according to the rules, you can set a growth factor for it."}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n  //...\r\n  maxRetryTimes: 3,\r\n  backoff: {\r\n    delay: 2000,\r\n    // highlight-start\r\n    // When multiplier is set to 2, the first retry delay is 2 seconds, the second is 4 seconds, and the third is 6 seconds\r\n    multiplier: 2\r\n    // highlight-end\r\n  }\r\n});\n"})}),"\n",(0,n.jsx)(r.p,{children:"not enough? You can even add a random jitter value to each delay to make it look less regular"}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n   //...\r\n   maxRetryTimes: 3,\r\n   backoff: {\r\n     delay: 2000,\r\n     multiplier: 2,\r\n     // highlight-start\r\n     /**\r\n      * The initial jitter percentage value of the delay request, the range is 0-1\r\n      * When only startQuiver is set, endQuiver defaults to 1\r\n      * For example set to 0.5, it will add 50% to 100% random time on the current delay time\r\n      * If endQuiver has a value, the delay time will be increased by a random value in the range of startQuiver and endQuiver\r\n      */\r\n     startQuiver: 0.5,\r\n\r\n     /**\r\n      * The jitter end percentage value of the delayed request, the range is 0-1\r\n      * When only endQuiver is set, startQuiver defaults to 0\r\n      * For example set to 0.8, it will add a random time from 0% to 80% on the current delay time\r\n      * If startQuiver has a value, the delay time will increase the random value in the range of startQuiver and endQuiver\r\n      */\r\n     endQuiver: 0.8;\r\n     // highlight-end\r\n   }\r\n});\n"})}),"\n",(0,n.jsx)(r.h2,{id:"set-retry-rules",children:"set retry rules"}),"\n",(0,n.jsx)(r.p,{children:"By default, as long as the request fails, it will be retried. The request failure is divided into the following situations:"}),"\n",(0,n.jsxs)(r.ol,{children:["\n",(0,n.jsxs)(r.li,{children:["The request is wrong, and the error is not caught by the global ",(0,n.jsx)(r.code,{children:"onError"})," hook;"]}),"\n",(0,n.jsxs)(r.li,{children:["The request was successful, but an error was thrown in the global ",(0,n.jsx)(r.code,{children:"onSuccess"})," hook;"]}),"\n"]}),"\n",(0,n.jsxs)(r.p,{children:["But in reality, not all requests need to be retried. For example, when a server error occurs or the network is disconnected, it should not be retried. In this case, it is necessary to set a retry judgment rule. When a request fails, an instance of ",(0,n.jsx)(r.code,{children:"Error"})," is usually obtained. We can set a regular expression to match ",(0,n.jsx)(r.code,{children:"error.message"})," or ",(0,n.jsx)(r.code,{children:"error.name"}),", and if the match passes, no retry will be made."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"useSQRequest(createOrEditTodo, {\r\n  //...\r\n  // highlight-start\r\n  // When the thrown error name is 500, or the wrong message matches network error, do not retry\r\n  retryError: {\r\n    name: /^500$/,\r\n    message: /network error/i\r\n  }\r\n  // highlight-end\r\n});\n"})}),"\n",(0,n.jsxs)(r.p,{children:["You can also set one of the matching rules. When only setting the matching rules for ",(0,n.jsx)(r.code,{children:"message"}),", it can be directly abbreviated as a regular expression."]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"// Only set the name that matches the error\r\nuseSQRequest(createOrEditTodo, {\r\n  //...\r\n  retryError: {\r\n    name: /^500$/\r\n  }\r\n});\r\n\r\n// Only set the message that matches the error\r\nuseSQRequest(createOrEditTodo, {\r\n  //...\r\n  retryError: /network error/i\r\n});\n"})}),"\n",(0,n.jsxs)(r.p,{children:["In order not to pollute the error message, usually we will put the error code returned by the server in ",(0,n.jsx)(r.code,{children:"error.name"}),", of course, you can also splice it into ",(0,n.jsx)(r.code,{children:"error.message"}),", the error handling example of Response is as follows:"]}),"\n",(0,n.jsx)(r.pre,{children:(0,n.jsx)(r.code,{className:"language-javascript",children:"const alovaInst = createAlova({\r\n  //...\r\n  responded: {\r\n    onSuccess(response) {\r\n      // Error thrown on 500 error\r\n      if (response.status === 500) {\r\n        const error = new Error(response.statusText);\r\n        error.name = response.status;\r\n        throw error;\r\n      }\r\n      return response.json();\r\n    }\r\n  }\r\n});\n"})}),"\n",(0,n.jsx)(r.p,{children:"In the next step, the saved operation records will be used to perform data compensation on the list data to achieve the latest state."})]})}function h(e={}){const{wrapper:r}={...(0,s.a)(),...e.components};return r?(0,n.jsx)(r,{...e,children:(0,n.jsx)(u,{...e})}):u(e)}},1151:(e,r,t)=>{t.d(r,{Z:()=>o,a:()=>i});var n=t(7294);const s={},a=n.createContext(s);function i(e){const r=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function o(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),n.createElement(a.Provider,{value:r},e.children)}}}]);