"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[9930],{28470:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>c,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>r});var i=a(85893),n=a(11151);const o={title:"Auto Invalidate"},c=void 0,s={id:"tutorial/cache/auto-invalidate",title:"Auto Invalidate",description:"Automatic invalidation cache is to set the matching rules of the invalidation source method in the target cache. When the source method is successfully requested, the target cache will be automatically matched and invalidated, and there is no need to manually clear the cache. When the target cache and the invalidation source are one-to-one or one-to-many, it is very convenient to set the automatic invalidation rule.",source:"@site/docs/tutorial/05-cache/02-auto-invalidate.md",sourceDirName:"tutorial/05-cache",slug:"/tutorial/cache/auto-invalidate",permalink:"/tutorial/cache/auto-invalidate",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/05-cache/02-auto-invalidate.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Auto Invalidate"},sidebar:"tutorial",previous:{title:"Cache Mode",permalink:"/tutorial/cache/mode"},next:{title:"Manual Invalidate",permalink:"/tutorial/cache/manually-invalidate"}},l={},r=[{value:"Usage scenarios",id:"usage-scenarios",level:2},{value:"Set automatic invalidation rules",id:"set-automatic-invalidation-rules",level:2},{value:"Set the invalidation source to the method instance",id:"set-the-invalidation-source-to-the-method-instance",level:3},{value:"Match the invalidation source by method name",id:"match-the-invalidation-source-by-method-name",level:3},{value:"Match invalidation source by method name regular expression",id:"match-invalidation-source-by-method-name-regular-expression",level:3},{value:"Combining failure sources",id:"combining-failure-sources",level:3},{value:"Automatic invalidation scope",id:"automatic-invalidation-scope",level:2},{value:"hitSource data type",id:"hitsource-data-type",level:2}];function h(e){const t={code:"code",h2:"h2",h3:"h3",li:"li",mermaid:"mermaid",ol:"ol",p:"p",pre:"pre",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"Automatic invalidation cache is to set the matching rules of the invalidation source method in the target cache. When the source method is successfully requested, the target cache will be automatically matched and invalidated, and there is no need to manually clear the cache. When the target cache and the invalidation source are one-to-one or one-to-many, it is very convenient to set the automatic invalidation rule."}),"\n",(0,i.jsx)(t.mermaid,{value:"flowchart\n  M1[method1 invalidation source pointing] --\x3e T1[target cache]\n  M11[method1 invalidation source pointing] --\x3e T2[target cache]\n  M2[method2 invalidation source pointing] --\x3e T2[target cache]\n  MN[methodN invalidation source pointing] --\x3e T2[target cache]"}),"\n",(0,i.jsx)(t.h2,{id:"usage-scenarios",children:"Usage scenarios"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsx)(t.li,{children:"After editing a list item and submitting it successfully, the cache data of the list item is automatically invalidated."}),"\n",(0,i.jsx)(t.li,{children:"On the server side, for example, the current cache needs to be invalidated after the user's personal information, configuration data, etc. are updated."}),"\n"]}),"\n",(0,i.jsx)(t.h2,{id:"set-automatic-invalidation-rules",children:"Set automatic invalidation rules"}),"\n",(0,i.jsxs)(t.p,{children:["It is very simple to set this rule. You can set the ",(0,i.jsx)(t.code,{children:"hitSource"})," parameter for it when creating a Method instance with cache."]}),"\n",(0,i.jsx)(t.h3,{id:"set-the-invalidation-source-to-the-method-instance",children:"Set the invalidation source to the method instance"}),"\n",(0,i.jsx)(t.p,{children:"Use a fixed method instance as the invalidation source. As long as the request of this method instance or its cloned instance succeeds, the target cache will be automatically cleared."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"alova.Get('/todo/1', {\n  // ...\n  hitSource: alova.Post('/todo', {})\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"match-the-invalidation-source-by-method-name",children:"Match the invalidation source by method name"}),"\n",(0,i.jsx)(t.p,{children:"Like the method matcher, you can specify the method name in hitSource to match the invalidation source. Multiple invalidation sources can be set to the same name. When the method instance with this name is requested successfully, the target cache will be automatically cleared."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"const methodSubmitTodo = data =>\n  alova.Post('/todo', data, {\n    name: 'submitTodo'\n  });\n\nalova.Get('/todo/1', {\n  // ...\n  // Match the invalidation source whose method instance name is submitTodo\n  hitSource: 'submitTodo'\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"match-invalidation-source-by-method-name-regular-expression",children:"Match invalidation source by method name regular expression"}),"\n",(0,i.jsx)(t.p,{children:"If the method instance name is not fixed, you can specify a regular expression in hitSource to match the method name. When the matched method instance is requested successfully, the target cache will be automatically cleared."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"const methodSubmitTodo = data =>\n  alova.Post('/todo', data, {\n    name: 'prefix-submitTodo'\n  });\n\nalova.Get('/todo/1', {\n  // ...\n  // Match all instances of method instance name starting with prefix\n  hitSource: /^prefix/\n});\n"})}),"\n",(0,i.jsx)(t.h3,{id:"combining-failure-sources",children:"Combining failure sources"}),"\n",(0,i.jsx)(t.p,{children:"If you want to use multiple rules above to match failure sources, you can specify hitSource as an array, where the array item is any of the above 3 rules, and method instances that meet any of the rules in the array will be matched."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-javascript",children:"alova.Get('/todo/1', {\n  // ...\n  // When the method instance request that satisfies any matching rule in the array is successful, this cache will be invalidated\n  hitSource: [alova.Post('/todo', {}), 'submitTodo', /^prefix/]\n});\n"})}),"\n",(0,i.jsx)(t.h2,{id:"automatic-invalidation-scope",children:"Automatic invalidation scope"}),"\n",(0,i.jsx)(t.p,{children:"Automatic invalidation will search for caches under all alova instances by default. Too many invalidation targets may lead to poor performance. If you want to control the scope of automatic invalidation or turn it off, you can set it as follows."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"import { globalConfig } from 'alova';\n\nglobalConfig({\n  /**\n   * Automatic hit cache switch.\n   * There are three options here:\n   * - global: invalidate cache across alova instances.\n   * - self: only invalidate caches from the same alova instance.\n   * - close: no longer automatically invalidate cache.\n   * Defaults to 'global'\n   */\n  autoHitCache: 'self'\n});\n"})}),"\n",(0,i.jsx)(t.h2,{id:"hitsource-data-type",children:"hitSource data type"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-typescript",children:"type hitSource = string | RegExp | Method | (string | RegExp | Method)[];\n"})})]})}function d(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(h,{...e})}):h(e)}},11151:(e,t,a)=>{a.d(t,{Z:()=>s,a:()=>c});var i=a(67294);const n={},o=i.createContext(n);function c(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:c(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);