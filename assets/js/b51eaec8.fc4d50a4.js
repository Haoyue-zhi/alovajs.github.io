"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[4766],{79968:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>v,contentTitle:()=>m,default:()=>x,frontMatter:()=>p,metadata:()=>g,toc:()=>f});var s=n(85893),a=n(11151),r=n(74866),o=n(85162),i=n(5902),l=n(45498);const d='<template>\n  <select v-model="userId">\n    <option :value="1">User 1</option>\n    <option :value="2">User 2</option>\n    <option :value="3">User 3</option>\n  </select>\n\n  \x3c!-- Render the filtered todo list --\x3e\n  <div v-if="loading">Loading...</div>\n  <ul v-else>\n    <li\n      v-for="todo in data"\n      :key="todo.id">\n      {{ todo.completed ? \'(Completed)\' : \'\' }}{{ todo.title }}\n    </li>\n  </ul>\n</template>\n\n<script setup>\nimport { useWatcher } from \'alova\';\nimport { ref } from \'vue\';\nimport { alovaInstance } from \'./api\';\n\n// Create method instance\nconst filterTodoList = userId => {\n  return alovaInstance.Get(`/users/${userId}/todos`);\n};\nconst userId = ref(1);\nconst { loading, data, error } = useWatcher(\n  // Must be set to a function that returns a method instance\n  () => filterTodoList(userId.value),\n\n  // The monitored status array, these status changes will trigger a request\n  [userId]\n);\n<\/script>\n',c="import { useWatcher } from 'alova';\nimport { useState } from 'react';\nimport { alovaInstance } from './api';\n\n//Create method instance\nconst filterTodoList = userId => {\n  return alovaInstance.Get(`/users/${userId}/todos`);\n};\n\nconst App = () => {\n  const [userId, setUserId] = useState(1);\n  const { loading, data = [] } = useWatcher(\n    // Must be set to a function that returns a method instance\n    () => filterTodoList(userId),\n\n    // The monitored status array, these status changes will trigger a request\n    [userId]\n  );\n\n  return (\n    <>\n      <select\n        value={userId}\n        onChange={e => setUserId(e.target.value)}>\n        <option value={1}>User 1</option>\n        <option value={2}>User 2</option>\n        <option value={3}>User 3</option>\n      </select>\n\n      {/* Render the filtered todo list */}\n      {loading ? <div>Loading...</div> : null}\n      {!loading ? (\n        <ul>\n          {data.map(todo => (\n            <li>\n              {todo.completed ? '(Completed)' : ''}\n              {todo.title}\n            </li>\n          ))}\n        </ul>\n      ) : null}\n    </>\n  );\n};\nexport default App;\n",h='<script>\r\nimport { writable } from \'svelte/store\';\r\n\r\n//Create method instance\r\nconst filterTodoList = userId => {\r\n  return alovaInstance.Get(`/users/${userId}/todos`);\r\n};\r\nconst userId = writable(0);\r\nconst { loading, data, error } = useWatcher(\r\n  // Parameters must be set to functions that return method instances\r\n  () => filterTodoList($userId),\r\n\r\n  // The monitored status array, these status changes will trigger a request\r\n  [userId]\r\n);\r\n<\/script>\r\n\r\n<select bind:value="{$userId}">\r\n  <option value="{1}">User 1</option>\r\n  <option value="{2}">User 2</option>\r\n  <option value="{3}">User 3</option>\r\n</select>\r\n\r\n\x3c!-- Render the filtered todo list --\x3e\r\n{#if $loading}\r\n<div>Loading...</div>\r\n{:else}\r\n<ul>\r\n  {#each $data as todo}\r\n    <li class="todo-title">{{ todo.completed ? \'(Completed)\' : \'\' }}{{ todo.title }}</li>\r\n  {/each}\r\n</ul>\r\n{/if}',u='<template>\n  <select v-model="userId">\n    <option :value="1">User 1</option>\n    <option :value="2">User 2</option>\n    <option :value="3">User 3</option>\n  </select>\n\n  \x3c!-- Render the filtered todo list --\x3e\n  <div v-if="todo.loading">Loading...</div>\n  <ul v-else>\n    <li\n      v-for="todoItem in todo.data"\n      :key="todoItem.id">\n      {{ todoItem.completed ? \'(Completed)\' : \'\' }}{{ todoItem.title }}\n    </li>\n  </ul>\n</template>\n\n<script>\nimport { mapAlovaHook } from \'@alova/vue-options\';\nimport { useWatcher } from \'alova\';\nimport { alovaInstance } from \'./api\';\n\n// Create method instance\nconst filterTodoList = userId => {\n  return alovaInstance.Get(`/users/${userId}/todos`);\n};\n\nexport default {\n  mixins: mapAlovaHook(function () {\n    return {\n      todo: useWatcher(\n        // Must be set to a function that returns a method instance\n        () => filterTodoList(this.userId),\n\n        // The monitored status array, these status changes will trigger a request\n        [\'userId\']\n      )\n    };\n  }),\n  data() {\n    return {\n      userId: 1\n    };\n  }\n};\n<\/script>\n',p={title:"Watching Request"},m=void 0,g={id:"tutorial/combine-framework/use-watcher",title:"Watching Request",description:"In some scenarios that require re-requesting as data changes, such as paging, data filtering, and fuzzy search, you can use useWatcher to monitor the specified states change and send a request immediately.",source:"@site/versioned_docs/version-v2/tutorial/03-combine-framework/03-use-watcher.md",sourceDirName:"tutorial/03-combine-framework",slug:"/tutorial/combine-framework/use-watcher",permalink:"/v2/tutorial/combine-framework/use-watcher",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/versioned_docs/version-v2/tutorial/03-combine-framework/03-use-watcher.md",tags:[],version:"v2",sidebarPosition:3,frontMatter:{title:"Watching Request"},sidebar:"tutorial",previous:{title:"Auto Manage States",permalink:"/v2/tutorial/combine-framework/use-request"},next:{title:"Initial Data",permalink:"/v2/tutorial/combine-framework/initial-data"}},v={},f=[{value:"Keyword search",id:"keyword-search",level:2},{value:"Pagination",id:"pagination",level:2},{value:"Send request immediately",id:"send-request-immediately",level:2},{value:"Request debounce",id:"request-debounce",level:2},{value:"Set debounce time of all watching states",id:"set-debounce-time-of-all-watching-states",level:3},{value:"Set debounce time for a single watching state",id:"set-debounce-time-for-a-single-watching-state",level:3},{value:"Block request when the states changes",id:"block-request-when-the-states-changes",level:2},{value:"Request timing",id:"request-timing",level:2}];function b(e){const t={admonition:"admonition",code:"code",h2:"h2",h3:"h3",mermaid:"mermaid",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In some scenarios that require re-requesting as data changes, such as paging, data filtering, and fuzzy search, you can use ",(0,s.jsx)(t.code,{children:"useWatcher"})," to monitor the specified states change and send a request immediately."]}),"\n",(0,s.jsx)(t.h2,{id:"keyword-search",children:"Keyword search"}),"\n",(0,s.jsx)(t.p,{children:"Next we take searching for todo items as an example. Try to change options in the search box and see how the todo list changes."}),"\n",(0,s.jsxs)(r.Z,{groupId:"framework",children:[(0,s.jsx)(o.Z,{value:"1",label:"vue",children:(0,s.jsx)(i.Z,{template:"vue",mainFile:d,editorHeight:800})}),(0,s.jsx)(o.Z,{value:"2",label:"react",children:(0,s.jsx)(i.Z,{template:"react",mainFile:c,editorHeight:800})}),(0,s.jsx)(o.Z,{value:"3",label:"svelte",children:(0,s.jsx)(l.Z,{language:"html",children:h})}),(0,s.jsx)(o.Z,{value:"4",label:"vue options",children:(0,s.jsx)(i.Z,{template:"vue",style:"options",mainFile:u,editorHeight:800})})]}),"\n",(0,s.jsx)(t.h2,{id:"pagination",children:"Pagination"}),"\n",(0,s.jsx)(t.p,{children:"Taking the todo list pagination request as an example, you can do this."}),"\n",(0,s.jsxs)(r.Z,{groupId:"framework",children:[(0,s.jsx)(o.Z,{value:"1",label:"vue",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<template>\n  \x3c!-- ... --\x3e\n</template>\n\n<script setup>\n  //method instance creation function\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/todo/list', {\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  const currentPage = ref(1);\n  const { loading, data, error } = useWatcher(\n    // The first parameter is the function that returns the method instance, not the method instance itself\n    () => getTodoList(currentPage.value),\n    // The watched states array, these states changes will trigger a request\n    [currentPage],\n    {\n      // \u26a0\ufe0fCalling useWatcher is not triggered by default. Please note the difference from useRequest.\n      // Manually set immediate to true to initially obtain the data on page 1\n      immediate: true\n    }\n  );\n<\/script>\n"})})}),(0,s.jsx)(o.Z,{value:"2",label:"react",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-jsx",children:"import { useState } from 'react';\n\n//method instance creation function\nconst getTodoList = currentPage => {\n  return alovaInstance.Get('/todo/list', {\n    params: {\n      currentPage,\n      pageSize: 10\n    }\n  });\n};\n\nconst App = () => {\n  const [currentPage, setCurrentPage] = useState(1);\n  const {\n    loading,\n    data,\n    error\n\n    // The first parameter is the function that returns the method instance, not the method instance itself\n  } = useWatcher(\n    () => getTodoList(currentPage),\n    // The watched states array, these states changes will trigger a request\n    [currentPage],\n    {\n      // \u26a0\ufe0fCalling useWatcher is not triggered by default. Please note the difference from useRequest.\n      // Manually set immediate to true to initially obtain the data on page 1\n      immediate: true\n    }\n  );\n\n  return {\n    /* ... */\n  };\n};\n"})})}),(0,s.jsx)(o.Z,{value:"3",label:"svelte",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<script>\n  import { writable } from 'svelte/store';\n\n  //method instance creation function\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/todo/list', {\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  const currentPage = writable(1);\n  const {\n    loading,\n    data,\n    error\n\n    // The first parameter is the function that returns the method instance, not the method instance itself\n  } = useWatcher(\n    () => getTodoList($currentPage),\n    // The watched states array, these states changes will trigger a request\n    [currentPage],\n    {\n      // \u26a0\ufe0fCalling useWatcher is not triggered by default. Please note the difference from useRequest.\n      // Manually set immediate to true to initially obtain the data on page 1\n      immediate: true\n    }\n  );\n<\/script>\n\n\x3c!-- ... --\x3e\n"})})}),(0,s.jsx)(o.Z,{value:"4",label:"vue options",children:(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-html",children:"<template>\n  \x3c!-- ... --\x3e\n</template>\n\n<script>\n  import { mapAlovaHook } from '@alovajs/vue-options';\n\n  //method instance creation function\n  const getTodoList = currentPage => {\n    return alovaInstance.Get('/todo/list', {\n      params: {\n        currentPage,\n        pageSize: 10\n      }\n    });\n  };\n\n  export default {\n    mixins: mapAlovaHook(function () {\n      paging: useWatcher(\n        () => getTodoList(this.currentPage),\n\n        // The watched states array, these states changes will trigger a request\n        ['currentPage'],\n        {\n          // \u26a0\ufe0fCalling useWatcher is not triggered by default. Please note the difference from useRequest.\n          // Manually set immediate to true to initially obtain the data on page 1\n          immediate: true\n        }\n      );\n    }),\n    data() {\n      return {\n        currentPage: 1\n      };\n    }\n  };\n<\/script>\n"})})})]}),"\n",(0,s.jsx)(t.h2,{id:"send-request-immediately",children:"Send request immediately"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"useWatcher"})," can also send the request immediately, but it should be noted that the ",(0,s.jsx)(t.code,{children:"immediate"})," attribute of ",(0,s.jsx)(t.code,{children:"useWatcher"})," defaults to ",(0,s.jsx)(t.code,{children:"false"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const { send } = useWatcher(() => getTodoList(currentPage), [currentPage], {\n  // highlight-start\n  immediate: true\n  // highlight-end\n});\nsend();\n"})}),"\n",(0,s.jsx)(t.h2,{id:"request-debounce",children:"Request debounce"}),"\n",(0,s.jsx)(t.p,{children:"Usually we write debounce code at the level of frequently triggered events. This time we implemented the debounce function at the request level, which means you no longer have to implement debounce yourself in the fuzzy search function, and the usage is also very simple."}),"\n",(0,s.jsx)(t.admonition,{title:"Tips: What is debounce?",type:"info",children:(0,s.jsx)(t.p,{children:"Debounce means that after an event is triggered, the function can only be executed once within n seconds. If an event is triggered again within n seconds after the event is triggered, the function delay execution time will be recalculated (here to distinguish between throttling, throttling means that the event cannot be triggered again within a period of time after the event is triggered)"})}),"\n",(0,s.jsx)(t.h3,{id:"set-debounce-time-of-all-watching-states",children:"Set debounce time of all watching states"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const { loading, data, error } = useWatcher(\n  () => filterTodoList(keyword, date),\n  [keyword, date],\n  {\n    // highlight-start\n    // When debounce is set to a number, it represents the anti-bounce time of all watching states, in milliseconds.\n    // This means that when one or more of the states keyword and date change, the request will be sent after 500ms.beg\n    debounce: 500\n    // highlight-end\n  }\n);\n"})}),"\n",(0,s.jsx)(t.h3,{id:"set-debounce-time-for-a-single-watching-state",children:"Set debounce time for a single watching state"}),"\n",(0,s.jsxs)(t.p,{children:["In many scenarios, we only need to debounce certain frequently changing watching states, such as state changes triggered by ",(0,s.jsx)(t.code,{children:"onInput"})," of a text box. You can do this:"]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"const { loading, data, error } = useWatcher(\n  () => filterTodoList(keyword, date),\n  [keyword, date],\n  {\n    // highlight-start\n    // Set debounce time in the order of the array of watching states. 0 or not passed means no debounce.\n    // The order of the watching states here is [keyword, date], and the debounce array setting is [500, 0], which means that only the debounce is set separately for the keyword.\n    Debounce: [500, 0]\n    // You can also set it as follows:\n    // debounce: [500],\n    // highlight-end\n  }\n);\n"})}),"\n",(0,s.jsx)(t.h2,{id:"block-request-when-the-states-changes",children:"Block request when the states changes"}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes you want not to send a request when the watched state changes. You can use the sendable attribute in the Hook configuration to control whether to send a request when the watched state changes. The sendable attribute is a function whose parameter is the ",(0,s.jsx)(t.code,{children:"AlovaEvent"})," event object. Contains the array ",(0,s.jsx)(t.code,{children:"sendArgs"})," composed of the parameters passed in by the ",(0,s.jsx)(t.code,{children:"send"})," function, and the ",(0,s.jsx)(t.code,{children:"method"})," instance of the current request, and the function returns a ",(0,s.jsx)(t.code,{children:"truthy/falsy"})," value to determine whether the request needs to be triggered when the states changes (default is ",(0,s.jsx)(t.code,{children:"true"}),"), ",(0,s.jsx)(t.strong,{children:"throwing an error also means not triggering the request"}),"."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"useWatcher(\n  () => getTodoList($currentPage),\n  // The watched states array, these states changes will trigger a request\n  [state],\n  {\n    // highlight-start\n    sendable: ({ sendArgs, method }) => {\n      // do something\n      // Only send request when state is 1\n      return state === 1;\n    }\n    // highlight-end\n  }\n);\n"})}),"\n",(0,s.jsx)(t.h2,{id:"request-timing",children:"Request timing"}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes when the states watched by ",(0,s.jsx)(t.code,{children:"useWatcher"})," changes continuously resulting in the initiation of consecutive requests, the latter request gets a response before the previous request, but when the previous request gets a response, it will overwrite the response of the latter request. Resulting in getting a response that does not match the state; for example, if the state ",(0,s.jsx)(t.code,{children:"state"})," changes, a request ",(0,s.jsx)(t.code,{children:"1"})," is issued, and then when the request ",(0,s.jsx)(t.code,{children:"1"})," has not responded, the value of ",(0,s.jsx)(t.code,{children:"state"})," is changed and a request",(0,s.jsx)(t.code,{children:" is issued. 2"}),", if request ",(0,s.jsx)(t.code,{children:"1"})," is returned after request ",(0,s.jsx)(t.code,{children:"2"}),", the final response data will remain at request ",(0,s.jsx)(t.code,{children:"1"}),".\nSo we designed the ",(0,s.jsx)(t.code,{children:"abortLast"})," parameter, which is used to mark whether to abort the last unresponsive request when the next request is issued. The default is ",(0,s.jsx)(t.code,{children:"true"}),", so that the request issued by ",(0,s.jsx)(t.code,{children:"useWatcher"})," is only valid for the last time."]}),"\n",(0,s.jsx)(t.mermaid,{value:"sequenceDiagram\n   participant U as User\n   participant S as Server\n   U ->> U: watch state\n   U ->> S: state change to trigger request 1\n   U ->> S: state change to trigger request 2\n   S ->> U: Request 2 responded first\n   S ->> U: Then request 1 responded\n   U ->> U: Response of request 2 is overwritten"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"useWatcher(\n  () => getTodoList($currentPage),\n  // The watched states array, these states changes will trigger a request\n  [state],\n  {\n    // highlight-start\n    abortLast: true // Whether to abort the last unresponsive request, the default is true\n    // highlight-end\n  }\n);\n"})}),"\n",(0,s.jsx)(t.admonition,{title:"Notes",type:"warning",children:(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"abortLast"})," defaults to ",(0,s.jsx)(t.code,{children:"true"}),". If it is changed to ",(0,s.jsx)(t.code,{children:"false"}),", it may cause the problem of states and response mismatch."]})})]})}function x(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(b,{...e})}):b(e)}},5902:(e,t,n)=>{n.d(t,{Z:()=>d});var s=n(59020),a=n(73808),r=n(92949),o=n(85893);const i={vue:{root:"/src/App.vue",files:{"/src/api.js":"import { createAlova } from 'alova';\nimport GlobalFetch from 'alova/GlobalFetch';\nimport VueHook from 'alova/vue';\nexport const alovaInstance = createAlova({\n  baseURL: 'https://jsonplaceholder.typicode.com',\n  statesHook: VueHook,\n  requestAdapter: GlobalFetch(),\n  responded: response => response.json()\n});\n"}},"vue-options":{root:"/src/App.vue",files:{"/src/api.js":"import { VueOptionsHook } from '@alova/vue-options';\nimport { createAlova } from 'alova';\nimport GlobalFetch from 'alova/GlobalFetch';\nexport const alovaInstance = createAlova({\n  baseURL: 'https://jsonplaceholder.typicode.com',\n  statesHook: VueOptionsHook,\n  requestAdapter: GlobalFetch(),\n  responded: response => response.json()\n});\n"},deps:{"@alova/vue-options":"^1"}},react:{root:"/App.js",files:{"/api.js":"import { createAlova } from 'alova';\nimport GlobalFetch from 'alova/GlobalFetch';\nimport ReactHook from 'alova/react';\nexport const alovaInstance = createAlova({\n  baseURL: 'https://jsonplaceholder.typicode.com',\n  statesHook: ReactHook,\n  requestAdapter: GlobalFetch(),\n  responded: response => response.json()\n});\n"}},svelte:{root:"/App.svelte",files:{"/api.js":"import { createAlova } from 'alova';\nimport GlobalFetch from 'alova/GlobalFetch';\nimport SvelteHook from 'alova/svelte';\nexport const alovaInstance = createAlova({\n  baseURL: 'https://jsonplaceholder.typicode.com',\n  statesHook: SvelteHook,\n  requestAdapter: GlobalFetch(),\n  responded: response => response.json()\n});\n"}},static:{root:"/index.html"},vanilla:{root:"/index.js"}},l={svelte:e=>({files:{"/index.js":{code:'import App from "./App.svelte";    \n  const app = new App({\n    target: document.body\n  });\n  export default app;\n        ',hidden:!0},"/public/index.html":{code:'<!DOCTYPE html>\n  <html>\n    <head>\n      <meta charset="utf8" />\n      <meta name="viewport" content="width=device-width" />\n      <title>Svelte app</title>\n      <link rel="stylesheet" href="public/bundle.css" />\n    </head>\n    <body>\n      <script src="bundle.js"><\/script>\n    </body>\n  </html>',hidden:!0},...e.files},customSetup:{entry:"/index.js",dependencies:{svelte:"^3.59.2",...e.customSetup.dependencies}},main:"/App.svelte",environment:"svelte"})},d=e=>{let{template:t,mainFile:n,externalFiles:d={},containBaseURL:c=!0,containResponded:h=!0,editorHeight:u,style:p}=e;const m={light:a.SF,dark:a.eq},g=i[t+(p?`-${p}`:"")],v={[g.root]:n,...g.files?g.files:{},...d},f=Object.keys(v).find((e=>/api\.js$/.test(e)));v[f]&&(c||(v[f]=v[f].replace(/baseURL.+?\s{4}/,"")),h||(v[f]=v[f].replace(/,\s+responded.+json\(\)/,"")));const b={alova:"^2",...g.deps||{}},{colorMode:x}=(0,r.I)();let j={files:v,template:t,customSetup:{dependencies:b}};return j=l[t]?l[t](j):j,(0,o.jsx)(s.xR,{...j,theme:m[x],options:{editorWidthPercentage:70,editorHeight:u}})}}}]);