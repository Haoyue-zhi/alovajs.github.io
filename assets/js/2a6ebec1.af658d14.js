"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[8806],{6614:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>r,toc:()=>h});var s=n(5893),a=n(1151);const o={title:"Update response status across pages/modules",sidebar_position:100},i=void 0,r={id:"tutorial/learning/update-response-data-across-modules",title:"Update response status across pages/modules",description:"In the example of the previous section Active Invalidation Response Cache, when the user clicks on an item in the todo list, enters the todo details page and executes Editing is done. At this time, we hope that the todo list data on the previous page will also be updated to the edited content. Using useFetcher and invalidateCache will re-initiate the request. Is there a method that does not need to re-request?",source:"@site/docs/tutorial/03-learning/10-update-response-data-across-modules.md",sourceDirName:"tutorial/03-learning",slug:"/tutorial/learning/update-response-data-across-modules",permalink:"/tutorial/learning/update-response-data-across-modules",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/03-learning/10-update-response-data-across-modules.md",tags:[],version:"current",sidebarPosition:100,frontMatter:{title:"Update response status across pages/modules",sidebar_position:100},sidebar:"tutorialSidebar",previous:{title:"Cache set and query",permalink:"/tutorial/learning/cache-set-and-query"},next:{title:"Next step",permalink:"/category/next-step"}},d={},h=[{value:"\u26a0\ufe0f Please make sure the component is not destroyed",id:"\ufe0f-please-make-sure-the-component-is-not-destroyed",level:2},{value:"Use the method instance to find the response status",id:"use-the-method-instance-to-find-the-response-status",level:2},{value:"Dynamically update the response status",id:"dynamically-update-the-response-status",level:2},{value:"Listen for matching events",id:"listen-for-matching-events",level:2},{value:"Precautions",id:"precautions",level:2}];function c(e){const t={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(t.p,{children:["In the example of the previous section ",(0,s.jsx)(t.a,{href:"/tutorial/learning/invalidate-response-cache",children:"Active Invalidation Response Cache"}),", when the user clicks on an item in the todo list, enters the todo details page and executes Editing is done. At this time, we hope that the todo list data on the previous page will also be updated to the edited content. Using ",(0,s.jsx)(t.code,{children:"useFetcher"})," and ",(0,s.jsx)(t.code,{children:"invalidateCache"})," will re-initiate the request. Is there a method that does not need to re-request?"]}),"\n",(0,s.jsxs)(t.p,{children:["Of course there is! alova provides ",(0,s.jsx)(t.code,{children:"updateState"})," to manually update the existing responsive state under any module/page. It is worth noting that the different response states are stored with the method instance that sent the request as the key, so the method instance will also be used to find the corresponding response state when updating the state."]}),"\n",(0,s.jsx)(t.h2,{id:"\ufe0f-please-make-sure-the-component-is-not-destroyed",children:"\u26a0\ufe0f Please make sure the component is not destroyed"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.code,{children:"updateState"})," will look for the response state created by alova's use hooks by default, and the destruction of a component will also recycle all the state created inside it at the same time, so when using ",(0,s.jsx)(t.code,{children:"updateState"}),", please make sure you want to update the response The container component corresponding to the status has not been destroyed, otherwise the corresponding response status will not be found and the update will fail."]}),"\n",(0,s.jsx)(t.p,{children:"This problem often occurs when the state is updated across pages, because what we tend to overlook when the page jumps is that the previous page has been destroyed by default. Therefore, if you want to update the state across pages, here are two suggestions :"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsx)(t.li,{children:"Persist the page components to ensure that the updated state can still be found."}),"\n",(0,s.jsxs)(t.li,{children:["Use ",(0,s.jsx)(t.a,{href:"/tutorial/learning/cache-set-and-query",children:"manually update the cache(setCache)"})," instead of ",(0,s.jsx)(t.code,{children:"updateState"}),", the principle is that when the request for the previous page exists in the cache, update its cache to ensure that it is created again page, the triggered request can hit the updated cache to achieve the same effect."]}),"\n"]}),"\n",(0,s.jsx)(t.p,{children:(0,s.jsxs)(t.a,{href:"/tutorial/example/update-state",children:["Here is a demo about ",(0,s.jsx)(t.code,{children:"updateState"})]})}),"\n",(0,s.jsx)(t.h2,{id:"use-the-method-instance-to-find-the-response-status",children:"Use the method instance to find the response status"}),"\n",(0,s.jsxs)(t.p,{children:["When determining the method instance corresponding to the updated response state, you can pass this method instance in ",(0,s.jsx)(t.code,{children:"updateState"}),", it will check whether there is a corresponding response state under this instance, and provide it to you for modification in the callback function, and finally Just return the modified data."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"import { updateState } from 'alova';\r\n\r\n// the todo item being edited\r\nconst editingTodo = {\r\n   id: 1,\r\n   title: 'todo1',\r\n   time: '09:00'\r\n};\r\n\r\nconst { send, onSuccess } = useRequest(createTodoPoster, { immediate: false });\r\nonSuccess(() => {\r\n   // highlight-start\r\n   // Fixedly modify the todo data on the first page\r\n   // updateState will return whether the update is successful\r\n   const updated = updateState(getTodoList(1), todoList => {\r\n     return todoList.map(item => {\r\n       if (item.id === editingTodo.id) {\r\n         return {\r\n           ...item,\r\n           ...editing Todo\r\n         };\r\n       }\r\n       return item;\r\n     });\r\n   });\r\n   // highlight-end\r\n});\n"})}),"\n",(0,s.jsx)(t.admonition,{title:"Caution",type:"warning",children:(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["When updating the state through ",(0,s.jsx)(t.code,{children:"updateState"}),", if the cache (memory cache and persistent cache) is detected, it will also update the new data update cache."]}),"\n",(0,s.jsx)(t.li,{children:"Alova will manage the status returned by the hook only when using useRequest and useWatcher to initiate a request. The reason is that the response status is generated and saved through a Method instance, but when no request is initiated, the url in the Method instance, Parameters such as params, query, and headers are still uncertain."}),"\n"]})}),"\n",(0,s.jsx)(t.h2,{id:"dynamically-update-the-response-status",children:"Dynamically update the response status"}),"\n",(0,s.jsxs)(t.p,{children:["Sometimes you may not be sure that you need to update the response status under the method, but you know how to find the cached data that needs to be invalidated. We can use ",(0,s.jsx)(t.a,{href:"/tutorial/next-step/method-instance-matcher",children:"Method instance matcher"})," to dynamically find the corresponding method instance. The following example shows adding a piece of data to the list corresponding to the method instance named todoList."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"updateState('todoList', todoListRaw => {\r\n  todoListRaw.push({\r\n    title: 'new todo',\r\n    time: '10:00'\r\n  });\r\n  return todoListRaw;\r\n});\n"})}),"\n",(0,s.jsx)(t.h2,{id:"listen-for-matching-events",children:"Listen for matching events"}),"\n",(0,s.jsxs)(t.p,{children:["When dynamically updating the response state, sometimes you may want to do some processing when the method instance is matched, or you want to get the matching method instance, ",(0,s.jsx)(t.code,{children:"updateState"})," can also pass in a third parameter to set the matching event to achieve these purposes ."]}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-javascript",children:"updateState(\r\n  'todoList',\r\n  todoListRaw => {\r\n    //...\r\n  },\r\n  {\r\n    // Called when a method instance is matched, the parameter is the matched method instance\r\n    onMatch: method => {\r\n      //...\r\n    }\r\n  }\r\n);\n"})}),"\n",(0,s.jsx)(t.h2,{id:"precautions",children:"Precautions"}),"\n",(0,s.jsxs)(t.ol,{children:["\n",(0,s.jsxs)(t.li,{children:["In actual use, whether you use ",(0,s.jsx)(t.code,{children:"useRequest"})," or ",(0,s.jsx)(t.code,{children:"useWatcher"})," to send a request, you can call the ",(0,s.jsx)(t.code,{children:"send"})," function to specify different parameters to send the request repeatedly, and the response status returned by these use hooks will be used by multiple method instances Reference, so you can choose any method instance to match the same response status value;"]}),"\n",(0,s.jsx)(t.li,{children:"When the dynamic search updates the response status, the method instance matcher finds multiple method instances, and the first instance will prevail;"}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(c,{...e})}):c(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>i});var s=n(7294);const a={},o=s.createContext(a);function i(e){const t=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:t},e.children)}}}]);