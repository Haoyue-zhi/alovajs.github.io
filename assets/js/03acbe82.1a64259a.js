"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[9104],{7362:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>s,metadata:()=>l,toc:()=>h});var a=n(5893),i=n(1151);const s={title:"Method Matcher",sidebar_position:30},r=void 0,l={id:"tutorial/advanced/method-matcher",title:"Method Matcher",description:"A method matcher is a method that dynamically finds a method instance in a list of requested method snapshots. It is generally used. When developers are not sure which method to use, they can use the method matcher to search according to certain rules.",source:"@site/docs/tutorial/06-advanced/03-method-matcher.md",sourceDirName:"tutorial/06-advanced",slug:"/tutorial/advanced/method-matcher",permalink:"/tutorial/advanced/method-matcher",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/06-advanced/03-method-matcher.md",tags:[],version:"current",sidebarPosition:30,frontMatter:{title:"Method Matcher",sidebar_position:30},sidebar:"tutorialSidebar",previous:{title:"Update states across components",permalink:"/tutorial/advanced/update-across-components"},next:{title:"Middleware",permalink:"/tutorial/advanced/middleware"}},c={},h=[{value:"Matching rules",id:"matching-rules",level:2},{value:"Match by name attribute",id:"match-by-name-attribute",level:2},{value:"Match by regular expression",id:"match-by-regular-expression",level:2},{value:"Filter matching results",id:"filter-matching-results",level:2},{value:"Differences in use in different functions",id:"differences-in-use-in-different-functions",level:2},{value:"invalidateCache",id:"invalidatecache",level:3},{value:"setCache",id:"setcache",level:3},{value:"updateState",id:"updatestate",level:3},{value:"fetch",id:"fetch",level:3},{value:"Limit instance snapshots",id:"limit-instance-snapshots",level:2}];function o(e){const t={a:"a",blockquote:"blockquote",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.p,{children:"A method matcher is a method that dynamically finds a method instance in a list of requested method snapshots. It is generally used. When developers are not sure which method to use, they can use the method matcher to search according to certain rules."}),"\n",(0,a.jsx)(t.h2,{id:"matching-rules",children:"Matching rules"}),"\n",(0,a.jsxs)(t.p,{children:["When a request is made using a method instance, it will be saved as a snapshot. The method matcher looks in these method snapshots based on the ",(0,a.jsx)(t.code,{children:"name"})," attribute set by the method instance. Multiple matchers are allowed to set the same ",(0,a.jsx)(t.code,{children:"name"}),"."]}),"\n",(0,a.jsx)(t.p,{children:"Method instance matching types are as follows:"}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"type MethodFilter =\r\n  | string\r\n  | RegExp\r\n  | {\r\n      name: string | RegExp;\r\n      filter: (method: Method, index: number, methods: Method[]) => boolean;\r\n\r\n      // Optional parameter, if the alova object is passed in, it will only match the Method instance created by this alova, otherwise it will match the Method instances of all alova instances.\r\n      alova?: Alova;\r\n    };\n"})}),"\n",(0,a.jsx)(t.p,{children:"The method instance matcher can be used in the following functions."}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/tutorial/cache/set-and-query",children:"setCache"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/tutorial/cache/set-and-query",children:"queryCache"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/tutorial/cache/manually-invalidate",children:"invalidateCache"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/tutorial/advanced/update-across-components",children:"updateState"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"/tutorial/advanced/use-fetcher",children:"useFetcher.fetch"})}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"match-by-name-attribute",children:"Match by name attribute"}),"\n",(0,a.jsx)(t.p,{children:"Matching is performed by passing in the complete instance name, and its matching result is an array."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"// Each time getTodoList is called, a new method instance will be generated, and their names are the same.\r\nconst getTodoList = currentPage =>\r\n  alova.Get('/todo/list', {\r\n    // highlight-start\r\n    name: 'todoList'\r\n    // highlight-end\r\n    // ...\r\n  });\r\n\r\n//The following means invalidating the cache of all Method instances with name 'todoList'\r\ninvalidateCache('todoList');\n"})}),"\n",(0,a.jsx)(t.h2,{id:"match-by-regular-expression",children:"Match by regular expression"}),"\n",(0,a.jsx)(t.p,{children:"By passing in a regular expression for matching, any method instance whose name matches the regular expression will be matched, and its result is also an array."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"// The following means invalidating the cache of all Method instances whose names start with 'todo'\r\ninvalidateCache(/^todo/);\n"})}),"\n",(0,a.jsx)(t.h2,{id:"filter-matching-results",children:"Filter matching results"}),"\n",(0,a.jsxs)(t.p,{children:["Further filter method instances that do not meet the conditions by specifying ",(0,a.jsx)(t.code,{children:"filter"}),". The filter function is used in the same way as Array.prototype.filter. Returning true indicates successful matching, and returning false indicates failure. See the type declaration above for details."]}),"\n",(0,a.jsx)(t.p,{children:"Let's look at a few examples."}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Invalidate the cache of the last method instance with a specific name"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"invalidateCache({\r\n  name: 'todoList',\r\n  filter: (method, index, methods) => index === methods.length - 1\r\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsxs)(t.strong,{children:["Set the cache of the last method instance of a specific name created by ",(0,a.jsx)(t.code,{children:"alovaInst"})]})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"setCache(\r\n  {\r\n    name: /^todo/,\r\n    filter: (method, index, methods) => index === methods.length - 1,\r\n\r\n    // If the alova parameter is passed, only the Method instances created by this alova instance will be matched, otherwise it will be matched in all Method instances.\r\n    alova: alovaInst\r\n  },\r\n  newCache\r\n);\n"})}),"\n",(0,a.jsx)(t.p,{children:(0,a.jsx)(t.strong,{children:"Repulse the last requested data from the todo list"})}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:"const { fetch } = useFetcher();\r\nfetch({\r\n  name: 'todoList',\r\n  filter: (method, index, methods) => index === methods.length - 1\r\n});\n"})}),"\n",(0,a.jsxs)(t.blockquote,{children:["\n",(0,a.jsx)(t.p,{children:"The alova parameter can further narrow the matching scope."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"differences-in-use-in-different-functions",children:"Differences in use in different functions"}),"\n",(0,a.jsx)(t.h3,{id:"invalidatecache",children:"invalidateCache"}),"\n",(0,a.jsx)(t.p,{children:"Apply the set of all matching Method instances, that is, invalidate the cache corresponding to all matching Method instances."}),"\n",(0,a.jsx)(t.h3,{id:"setcache",children:"setCache"}),"\n",(0,a.jsx)(t.p,{children:"All matching Method instance collections are applied. When static data is passed in, all Method instance caches are set to the same value. When the callback function is passed in, this function will be called cyclically and the return value will be used as cache data."}),"\n",(0,a.jsx)(t.h3,{id:"updatestate",children:"updateState"}),"\n",(0,a.jsx)(t.p,{children:"The first matching Method instance is applied."}),"\n",(0,a.jsx)(t.h3,{id:"fetch",children:"fetch"}),"\n",(0,a.jsx)(t.p,{children:"The first matching Method instance is applied, i.e. the data will only be pulled once."}),"\n",(0,a.jsx)(t.h2,{id:"limit-instance-snapshots",children:"Limit instance snapshots"}),"\n",(0,a.jsxs)(t.p,{children:[(0,a.jsx)(t.code,{children:"[v2.20.0+]"})," By default, 1000 method instance snapshots will be saved, otherwise memory overflow may occur in frequent request scenarios. You can also adjust the limit as needed."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import { globalConfig } from 'alova';\r\n\r\nglobalConfig({\r\n  // Limit saving to 500 instance snapshots\r\n  limitSnapshots: 500\r\n});\n"})}),"\n",(0,a.jsx)(t.p,{children:"When set to 0, instance snapshots are no longer saved and the method matcher cannot be used."}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"globalConfig({\r\n  limitSnapshots: 0\r\n});\n"})})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(o,{...e})}):o(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>l,a:()=>r});var a=n(7294);const i={},s=a.createContext(i);function r(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);