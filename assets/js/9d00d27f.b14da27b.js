"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[4146],{4680:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>c,default:()=>f,frontMatter:()=>i,metadata:()=>l,toc:()=>h});var r=n(5893),a=n(1151),o=n(4866),s=n(5162);const i={title:"Data fetching",sidebar_position:10},c=void 0,l={id:"tutorial/advanced/data-fetching",title:"Data fetching",description:"When you have the following needs:",source:"@site/docs/tutorial/05-advanced/01-data-fetching.md",sourceDirName:"tutorial/05-advanced",slug:"/tutorial/advanced/data-fetching",permalink:"/tutorial/advanced/data-fetching",draft:!1,unlisted:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/tutorial/05-advanced/01-data-fetching.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"Data fetching",sidebar_position:10},sidebar:"tutorialSidebar",previous:{title:"Advanced",permalink:"/category/advanced"},next:{title:"Update response states across pages/modules",permalink:"/tutorial/advanced/update-states-across-modules"}},d={},h=[{value:"Update views across modules/components",id:"update-views-across-modulescomponents",level:2},{value:"Preload data",id:"preload-data",level:2},{value:"Force sending request",id:"force-sending-request",level:2},{value:"Bind response callback",id:"bind-response-callback",level:2},{value:"Compare the differences between useRequest and useFetcher",id:"compare-the-differences-between-userequest-and-usefetcher",level:2}];function u(e){const t={a:"a",admonition:"admonition",blockquote:"blockquote",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,a.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.p,{children:"When you have the following needs:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsx)(t.li,{children:"Preload the data that will be used in subsequent processes and store it in the cache, so that users no longer have to wait for the data loading process;"}),"\n",(0,r.jsx)(t.li,{children:"Conveniently implement cross-page data update (similar to global state), for example, modify an item in the todo list and then re-fetch the latest data, and the interface will be refreshed after the response."}),"\n"]}),"\n",(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.code,{children:"useFetcher"})," is the hook used to implement the above scenario. The response data obtained through it cannot be received directly, but the data fetching through it will not only update the cache, but also update the corresponding state, thereby re-rendering the view."]}),"\n",(0,r.jsx)(t.p,{children:"You can use it to pre-fetch data and save it to the cache, or elegantly update the status across components, such as modifying an item in the todo list and then re-fetching the latest data, and the interface will be refreshed after the response."}),"\n",(0,r.jsx)(t.h2,{id:"update-views-across-modulescomponents",children:"Update views across modules/components"}),"\n",(0,r.jsx)(t.p,{children:"Next, we will modify a certain todo data and re-fetch the latest todo list data to update the view."}),"\n",(0,r.jsxs)(o.Z,{groupId:"framework",children:[(0,r.jsx)(s.Z,{value:"1",label:"vue composition",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- Render unified fetch state. --\x3e\r\n  <div v-if=\"fetching\">{{ Fetching data in the background... }}</div>\r\n\r\n  \x3c!-- ... --\x3e\r\n  <button @click=\"handleSubmit\">Modify todo items</button>\r\n</template>\r\n\r\n<script setup>\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      // Note: The name attribute is set here to filter out the required Method instances when the Method instance cannot be specified directly.\r\n      // See the subsequent \"Method Instance Matcher\" chapter for details.\r\n      name: 'todoList',\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const {\r\n    // The fetching attribute is the same as loading. It is true when sending the fetch request and false after the request is completed.\r\n    fetching,\r\n    error,\r\n    onSuccess,\r\n    onError,\r\n    onComplete,\r\n\r\n    // Only after calling fetch will a request be sent to fetch data. You can call fetch repeatedly to fetch data from different interfaces.\r\n    fetch\r\n  } = useFetcher();\r\n\r\n  // Trigger data fetch in event\r\n  const handleSubmit = () => {\r\n    // Todo item modification...\r\n\r\n    // Start fetching updated data\r\n    // Case 1: When you clearly know to fetch the first page of todoList data, pass in a Method instance\r\n    fetch(getTodoList(1));\r\n\r\n    // Situation 2: When you only know to fetch the data of the last request of todoList, filter it through the Method instance matcher\r\n    fetch({\r\n      name: 'todoList',\r\n      filter: (method, index, ary) => {\r\n        // Return true to specify the Method instance that needs to be fetched\r\n        return index === ary.length - 1;\r\n      }\r\n    });\r\n  };\r\n<\/script>\n"})})}),(0,r.jsx)(s.Z,{value:"2",label:"react",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"const getTodoList = currentPage => {\r\nreturn alovaInstance.Get('/todo/list', {\r\n// Note: The name attribute is set here to filter out the required Method instances when the Method instance cannot be specified directly.\r\n// See the subsequent \"Method Instance Matcher\" chapter for details.\r\nname: 'todoList',\r\nparams: {\r\ncurrentPage,\r\npageSize: 10\r\n}\r\n});\r\n};\r\n\r\nconst App = () => {\r\nconst {\r\n// The fetching attribute is the same as loading. It is true when sending the fetch request and false after the request is completed.\r\nfetching,\r\nerror,\r\nonSuccess,\r\nonError,\r\nonComplete,\r\n\r\n// Only after calling fetch will a request be sent to fetch data. You can call fetch repeatedly to fetch data from different interfaces.\r\nfetch\r\n} = useFetcher();\r\n\r\n// Trigger data fetch in event\r\nconst handleSubmit = () => {\r\n// Assume that the modification of todo items has been completed...\r\n\r\n// Start fetching updated data\r\n// Case 1: When you clearly know to fetch the first page of todoList data, pass in a Method instance\r\nfetch(getTodoList(1));\r\n\r\n// Situation 2: When you only know to fetch the data of the last request of todoList, filter it through the Method instance matcher\r\nfetch({\r\nname: 'todoList',\r\nfilter: (method, index, ary) => {\r\n// Return true to specify the Method instance that needs to be fetched\r\nreturn index === ary.length - 1;\r\n}\r\n});\r\n};\r\n\r\nreturn (\r\n{/* Render unified fetch status */}\r\n{ fetching ? <div>{{ Fetching data in the background... }}</div> : null }\r\n{/* ... */}\r\n<button onClick={handleSubmit}>Modify todo items</button>\r\n);\r\n};\n"})})}),(0,r.jsx)(s.Z,{value:"3",label:"svelte",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<script>\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      // Note: The name attribute is set here to filter out the required Method instances when the Method instance cannot be specified directly.\r\n      // See the subsequent \"Method Instance Matcher\" chapter for details.\r\n      name: 'todoList',\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const {\r\n    // The fetching attribute is the same as loading. It is true when sending the fetch request and false after the request is completed.\r\n    fetching,\r\n    error,\r\n    onSuccess,\r\n    onError,\r\n    onComplete,\r\n\r\n    // Only after calling fetch will a request be sent to fetch data. You can call fetch repeatedly to fetch data from different interfaces.\r\n    fetch\r\n  } = useFetcher();\r\n\r\n  // Trigger data fetch in event\r\n  const handleSubmit = () => {\r\n    // Assume that the modification of todo items has been completed...\r\n\r\n    // Start fetching updated data\r\n    // Case 1: When you clearly know to fetch the first page of todoList data, pass in a Method instance\r\n    fetch(getTodoList(1));\r\n\r\n    // Situation 2: When you only know to fetch the data of the last request of todoList, filter it through the Method instance matcher\r\n    fetch({\r\n      name: 'todoList',\r\n      filter: (method, index, ary) => {\r\n        // Return true to specify the Method instance that needs to be fetched\r\n        return index === ary.length - 1;\r\n      }\r\n    });\r\n  };\r\n<\/script>\r\n\r\n\x3c!-- Render unified fetch status --\x3e\r\n{#if $fetching}\r\n<div>{{ Fetching data in the background... }}</div>\r\n{/if}\r\n\x3c!-- ... --\x3e\r\n<button on:click=\"{handleSubmit}\">Modify todo items</button>\n"})})}),(0,r.jsx)(s.Z,{value:"4",label:"vue options",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- Render unified fetch state. --\x3e\r\n  <div v-if=\"fetcher.fetching\">{{ Fetching data in the background... }}</div>\r\n\r\n  \x3c!-- ... --\x3e\r\n  <button @click=\"handleSubmit\">Modify todo items</button>\r\n</template>\r\n\r\n<script>\r\n     import { mapAlovaHook } from '@alova/vue-options';\r\n     import { useFetcher } from 'alova';\r\n\r\n     const getTodoList = currentPage => {\r\n       return alovaInstance.Get('/todo/list', {\r\n         // Note: The name attribute is set here to filter out the required Method instances when the Method instance cannot be specified directly.\r\n         // See the subsequent \"Method Instance Matcher\" chapter for details.\r\n         name: 'todoList',\r\n         params: {\r\n           currentPage,\r\n           pageSize: 10\r\n         }\r\n       });\r\n     };\r\n\r\n     export default {\r\n       mixins: mapAlovaHook(function () {\r\n         const {\r\n           // The fetching attribute is the same as loading. It is true when sending the fetch request and false after the request is completed.\r\n           fetching,\r\n           error,\r\n           onSuccess,\r\n           onError,\r\n           onComplete,\r\n\r\n           // Only after calling fetch will a request be sent to fetch data. You can call fetch repeatedly to fetch data from different interfaces.\r\n           fetch\r\n         } = (fetcherStates = useFetcher());\r\n         return {\r\n           fetcher: fetcherStates\r\n         };\r\n       }),\r\n       methods: {\r\n         // Trigger data fetch in event\r\n         handleSubmit() {\r\n           // Start fetching updated data\r\n           // Case 1: When you clearly know to fetch the first page of todoList data, pass in a Method instance\r\n           this.fetcher$fetch(getTodoList(1));\r\n\r\n           // Situation 2: When you only know to fetch the data of the last request of todoList, filter it through the Method instance matcher\r\n           this.fetcher$fetch({\r\n             name: 'todoList',\r\n             filter\r\n  ```r: (method, index, ary) => {\r\n               // Return true to specify the Method instance that needs to be fetched\r\n               return index === ary.length - 1;\r\n             }\r\n           });\r\n         }\r\n       }\r\n     };\r\n<\/script>\n"})})})]}),"\n",(0,r.jsxs)(t.blockquote,{children:["\n",(0,r.jsxs)(t.p,{children:["For more information on how to use the ",(0,r.jsx)(t.code,{children:"Method"})," instance matcher, see ",(0,r.jsx)(t.a,{href:"/tutorial/advanced/method-matcher",children:"Method matcher"})]}),"\n"]}),"\n",(0,r.jsx)(t.h2,{id:"preload-data",children:"Preload data"}),"\n",(0,r.jsx)(t.p,{children:"The following implements the preloading function of the next page data in the todo list paging scenario."}),"\n",(0,r.jsxs)(o.Z,{groupId:"framework",children:[(0,r.jsx)(s.Z,{value:"1",label:"vue composition",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- ... --\x3e\r\n</template>\r\n\r\n<script setup>\r\n  //method instance creation function\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const { fetch } = useFetcher();\r\n\r\n  const currentPage = ref(1);\r\n  const { data, onSuccess } = useWatcher(() => getTodoList(currentPage.value), [currentPage], {\r\n    immediate: true\r\n  });\r\n\r\n  // Pre-fetch the data of the next page when the current page request is successful\r\n  //Realize that there is no need to wait for a request when turning the page to the next page\r\n  onSuccess(() => {\r\n    fetch(getTodoList(currentPage.value + 1));\r\n  });\r\n<\/script>\n"})})}),(0,r.jsx)(s.Z,{value:"2",label:"react",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-jsx",children:"import { useState } from 'react';\r\n\r\n//method instance creation function\r\nconst getTodoList = currentPage => {\r\n  return alovaInstance.Get('/todo/list', {\r\n    params: {\r\n      currentPage,\r\n      pageSize: 10\r\n    }\r\n  });\r\n};\r\n\r\nconst App = () => {\r\n  const { fetch } = useFetcher();\r\n  const [currentPage, setCurrentPage] = useState(1);\r\n  const { data, onSuccess } = useWatcher(() => getTodoList(currentPage), [currentPage], {\r\n    immediate: true\r\n  });\r\n\r\n  // Pre-fetch the data of the next page when the current page request is successful\r\n  //Realize that there is no need to wait for a request when turning the page to the next page\r\n  onSuccess(() => {\r\n    fetch(getTodoList(currentPage + 1));\r\n  });\r\n\r\n  return {\r\n    /* ... */\r\n  };\r\n};\n"})})}),(0,r.jsx)(s.Z,{value:"3",label:"svelte",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<script>\r\n  import { writable } from 'svelte/store';\r\n\r\n  //method instance creation function\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  const { fetch } = useFetcher();\r\n  const currentPage = writable(1);\r\n  const { data, onSuccess } = useWatcher(() => getTodoList($currentPage), [currentPage], {\r\n    immediate: true\r\n  });\r\n\r\n  // Pre-fetch the data of the next page when the current page request is successful\r\n  //Realize that there is no need to wait for a request when turning the page to the next page\r\n  onSuccess(() => {\r\n    fetch(getTodoList($currentPage + 1));\r\n  });\r\n<\/script>\r\n\r\n\x3c!-- views... --\x3e\n"})})}),(0,r.jsx)(s.Z,{value:"4",label:"vue options",children:(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-html",children:"<template>\r\n  \x3c!-- ... --\x3e\r\n</template>\r\n\r\n<script>\r\n  import { mapAlovaHook } from '@alova/vue-options';\r\n  import { useFetcher, useWatcher } from 'alova';\r\n\r\n  //method instance creation function\r\n  const getTodoList = currentPage => {\r\n    return alovaInstance.Get('/todo/list', {\r\n      params: {\r\n        currentPage,\r\n        pageSize: 10\r\n      }\r\n    });\r\n  };\r\n\r\n  export default {\r\n    mixins: mapAlovaHook(function () {\r\n      return {\r\n        fetcher: useFetcher(),\r\n        paging: useWatcher(() => getTodoList(this.currentPage), ['currentPage'], {\r\n          immediate: true\r\n        })\r\n      };\r\n    }),\r\n    data() {\r\n      return {\r\n        currentPage: 1\r\n      };\r\n    },\r\n    mounted() {\r\n      // Pre-fetch the data of the next page when the current page request is successful\r\n      //Realize that there is no need to wait for a request when turning the page to the next page\r\n      this.paging$onSuccess(() => {\r\n        this.fetcher$fetch(getTodoList(this.currentPage + 1));\r\n      });\r\n    }\r\n  };\r\n<\/script>\n"})})})]}),"\n",(0,r.jsx)(t.admonition,{title:"Notes",type:"warning",children:(0,r.jsxs)(t.p,{children:["useFetcher only updates the cache after the request is completed, and if it is found that there is ",(0,r.jsx)(t.code,{children:"data"})," status under the ",(0,r.jsx)(t.code,{children:"Method"})," instance, it will also be updated synchronously to ensure that the page data is consistent. This is ",(0,r.jsx)(t.code,{children:"useFetcher"})," used to update views across modules/components. ensure."]})}),"\n",(0,r.jsx)(t.h2,{id:"force-sending-request",children:"Force sending request"}),"\n",(0,r.jsxs)(t.p,{children:["Same as ",(0,r.jsx)(t.code,{children:"useRequest"})," and ",(0,r.jsx)(t.code,{children:"useWatcher"}),", please read ",(0,r.jsx)(t.a,{href:"/tutorial/cache/force-request",children:"Force Request"})," for more information."]}),"\n",(0,r.jsx)(t.h2,{id:"bind-response-callback",children:"Bind response callback"}),"\n",(0,r.jsxs)(t.p,{children:["In the above example, the fetch function is called to trigger data fetching. The fetch function can also pass in custom parameters starting from the second parameter. These parameters will also be used by the callback functions of ",(0,r.jsx)(t.code,{children:"onSuccess/onError/onComplete"})," and ",(0,r.jsx)(t.code,{children:" force"})," function is received. For details, please read the ",(0,r.jsx)(t.strong,{children:"send function parameter passing rules"})," section in ",(0,r.jsx)(t.a,{href:"/tutorial/getting-started/request-manually",children:"request manually"}),"."]}),"\n",(0,r.jsx)(t.h2,{id:"compare-the-differences-between-userequest-and-usefetcher",children:"Compare the differences between useRequest and useFetcher"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:["useFetcher does not return the ",(0,r.jsx)(t.code,{children:"data"})," field, the pre-fetched data will be saved in the cache, and the status data of the corresponding location will be updated;"]}),"\n",(0,r.jsxs)(t.li,{children:["Renamed ",(0,r.jsx)(t.code,{children:"loading"})," to ",(0,r.jsx)(t.code,{children:"fetching"}),";"]}),"\n",(0,r.jsxs)(t.li,{children:["There is no ",(0,r.jsx)(t.code,{children:"send"})," function, but there is a ",(0,r.jsx)(t.code,{children:"fetch"})," function. You can reuse the fetch function to fetch data from different interfaces. At this time, you can use the ",(0,r.jsx)(t.code,{children:"fetching"})," and ",(0,r.jsx)(t.code,{children:"error"})," states to uniformly render the view to achieve unified processing. the goal of;"]}),"\n"]})]})}function f(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(u,{...e})}):u(e)}},5162:(e,t,n)=>{n.d(t,{Z:()=>s});n(7294);var r=n(4334);const a={tabItem:"tabItem_Ymn6"};var o=n(5893);function s(e){let{children:t,hidden:n,className:s}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.Z)(a.tabItem,s),hidden:n,children:t})}},4866:(e,t,n)=>{n.d(t,{Z:()=>j});var r=n(7294),a=n(4334),o=n(2466),s=n(6550),i=n(469),c=n(1980),l=n(7392),d=n(12);function h(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function u(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return h(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:a}}=e;return{value:t,label:n,attributes:r,default:a}}))}(n);return function(e){const t=(0,l.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function f(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function p(e){let{queryString:t=!1,groupId:n}=e;const a=(0,s.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,c._X)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(a.location.search);t.set(o,e),a.replace({...a.location,search:t.toString()})}),[o,a])]}function m(e){const{defaultValue:t,queryString:n=!1,groupId:a}=e,o=u(e),[s,c]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!f({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[l,h]=p({queryString:n,groupId:a}),[m,g]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[a,o]=(0,d.Nk)(n);return[a,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:a}),b=(()=>{const e=l??m;return f({value:e,tabValues:o})?e:null})();(0,i.Z)((()=>{b&&c(b)}),[b]);return{selectedValue:s,selectValue:(0,r.useCallback)((e=>{if(!f({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),g(e)}),[h,g,o]),tabValues:o}}var g=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=n(5893);function x(e){let{className:t,block:n,selectedValue:r,selectValue:s,tabValues:i}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.o5)(),d=e=>{const t=e.currentTarget,n=c.indexOf(t),a=i[n].value;a!==r&&(l(t),s(a))},h=e=>{let t=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const n=c.indexOf(e.currentTarget)+1;t=c[n]??c[0];break}case"ArrowLeft":{const n=c.indexOf(e.currentTarget)-1;t=c[n]??c[c.length-1];break}}t?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.Z)("tabs",{"tabs--block":n},t),children:i.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>c.push(e),onKeyDown:h,onClick:d,...o,className:(0,a.Z)("tabs__item",b.tabItem,o?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function w(e){let{lazy:t,children:n,selectedValue:a}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===a));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==a})))})}function y(e){const t=m(e);return(0,v.jsxs)("div",{className:(0,a.Z)("tabs-container",b.tabList),children:[(0,v.jsx)(x,{...e,...t}),(0,v.jsx)(w,{...e,...t})]})}function j(e){const t=(0,g.Z)();return(0,v.jsx)(y,{...e,children:h(e.children)},String(t))}},1151:(e,t,n)=>{n.d(t,{Z:()=>i,a:()=>s});var r=n(7294);const a={},o=r.createContext(a);function s(e){const t=r.useContext(o);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(o.Provider,{value:t},e.children)}}}]);