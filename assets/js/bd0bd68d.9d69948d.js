"use strict";(self.webpackChunkalova_website=self.webpackChunkalova_website||[]).push([[6382],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},h=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),p=c(n),m=i,u=p["".concat(l,".").concat(m)]||p[m]||d[m]||o;return n?a.createElement(u,r(r({ref:t},h),{},{components:n})):a.createElement(u,r({ref:t},h))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var c=2;c<o;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},8080:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var a=n(7462),i=(n(7294),n(3905));const o={title:"Method instance matcher",sidebar_position:40},r=void 0,s={unversionedId:"next-step/method-instance-matcher",id:"next-step/method-instance-matcher",title:"Method instance matcher",description:"When we finish processing some business, we need to call invalidateCache, setCache, updateState and fetch to invalidate cache, update cache, update state across pages, or re-pull data, there are generally two scenarios :",source:"@site/docs/06-next-step/05-method-instance-matcher.md",sourceDirName:"06-next-step",slug:"/next-step/method-instance-matcher",permalink:"/next-step/method-instance-matcher",draft:!1,editUrl:"https://github.com/alovajs/alovajs.github.io/blob/main/docs/06-next-step/05-method-instance-matcher.md",tags:[],version:"current",sidebarPosition:40,frontMatter:{title:"Method instance matcher",sidebar_position:40},sidebar:"tutorialSidebar",previous:{title:"method metadata",permalink:"/next-step/method-metadata"},next:{title:"Automatic cache invalidation",permalink:"/next-step/auto-invalidate-cache"}},l={},c=[{value:"match by name attribute",id:"match-by-name-attribute",level:2},{value:"match by regular expression",id:"match-by-regular-expression",level:2},{value:"More complex matching methods",id:"more-complex-matching-methods",level:2},{value:"Differences used in different functions",id:"differences-used-in-different-functions",level:2}],h={toc:c};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"When we finish processing some business, we need to call ",(0,i.kt)("inlineCode",{parentName:"p"},"invalidateCache"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"setCache"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"updateState")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"fetch")," to invalidate cache, update cache, update state across pages, or re-pull data, there are generally two scenarios :"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"The developer knows which request data needs to be manipulated. At this time, when calling the above function, a ",(0,i.kt)("inlineCode",{parentName:"li"},"Method")," instance can be directly passed in;"),(0,i.kt)("li",{parentName:"ol"},"The developer only knows the request that needs to operate a certain order bit, but is not sure which one. At this time, we can use the method of ",(0,i.kt)("inlineCode",{parentName:"li"},"Method")," instance matcher to filter out.")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"Method")," instance matcher is filtered according to the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," attribute set by the ",(0,i.kt)("inlineCode",{parentName:"p"},"Method")," instance. Multiple matchers are allowed to set the same ",(0,i.kt)("inlineCode",{parentName:"p"},"name"),", so first you need to set the ",(0,i.kt)("inlineCode",{parentName:"p"},"name")," attribute for the ",(0,i.kt)("inlineCode",{parentName:"p"},"Method")," instance that needs to be filtered. ."),(0,i.kt)("p",null,"Method instance matching types are as follows"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"type MethodFilter =\n  | string\n  | RegExp\n  | {\n      name: string | RegExp;\n      filter: (method: Method, index: number, methods: Method[]) => boolean;\n\n      // Optional parameter, if an alova object is passed in, only the Method instance created by this alova is matched, otherwise it matches the Method instance of all alova instances\n      alova?: alova;\n    };\n")),(0,i.kt)("h2",{id:"match-by-name-attribute"},"match by name attribute"),(0,i.kt)("p",null,"Match by passing in the full instance name, and its result is an array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// Each time getTodoList is called, a new Method instance is generated with the same name\nconst getTodoList = currentPage =>\n  alova.Get('/todo/list', {\n    name: 'todoList',\n    params: {\n      currentPage,\n      pageSize: 10\n    }\n  });\n\n// The following means to invalidate the cache of all Method instances whose name is 'todoList'\ninvalidateCache('todoList');\n")),(0,i.kt)("h2",{id:"match-by-regular-expression"},"match by regular expression"),(0,i.kt)("p",null,"By passing in the regular expression to match, the name of the Method instance that matches the regular expression will be matched, and its result is also an array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// The following means to invalidate the cache of all Method instances whose name starts with 'todo'\ninvalidateCache(/^todo/);\n")),(0,i.kt)("h2",{id:"more-complex-matching-methods"},"More complex matching methods"),(0,i.kt)("p",null,"You can also specify ",(0,i.kt)("inlineCode",{parentName:"p"},"filter")," to further filter ",(0,i.kt)("inlineCode",{parentName:"p"},"Method")," instances that do not meet the conditions. The filter function is used in the same way as Array.prototype.filter. Returning true means the match is successful, and returning false means failure. For details, see the type declaration above."),(0,i.kt)("p",null,"Let's look at a few examples."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// invalidate the cache of the last Method instance whose name is todoList\ninvalidateCache({\n  name: 'todoList',\n  filter: (method, index, methods) => index === methods.length - 1\n});\n\n// Set the cache for the last Method instance whose name starts with todo\nsetCache(\n  {\n    name: /^todo/,\n    filter: (method, index, methods) => index === methods.length - 1,\n\n    // If the alova parameter is passed, only the Method instance created by this alova instance will be matched, otherwise it will be matched in all Method instances\n    alova: alovaInst\n  },\n  newCache\n);\n\n// Re-pull the data of the last request of the todo list\nconst { fetch } = useFetcher();\nfetch({\n  name: 'todoList',\n  filter: (method, index, methods) => index === methods.length - 1\n});\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"alova parameter to further narrow the match.")),(0,i.kt)("h2",{id:"differences-used-in-different-functions"},"Differences used in different functions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"invalidateCache: apply all matching Method instance sets, that is, invalidate the cache corresponding to all matching Method instances;"),(0,i.kt)("li",{parentName:"ul"},"setCache: applies all matching Method instance sets. When static data is passed in, all Method instance caches are set to the same value. When the callback function is passed in, this function will be called cyclically, and the return value will be used as the cached data;"),(0,i.kt)("li",{parentName:"ul"},"updateState: applies the first matching Method instance"),(0,i.kt)("li",{parentName:"ul"},"fetch: apply the first matching Method instance, that is, only pull data once\n",(0,i.kt)("inlineCode",{parentName:"li"},"invalidateCache")," will invalidate the cache corresponding to all filtered ",(0,i.kt)("inlineCode",{parentName:"li"},"Method")," instances, while ",(0,i.kt)("inlineCode",{parentName:"li"},"updateState")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"fetch")," will only operate on the first item in the set of ",(0,i.kt)("inlineCode",{parentName:"li"},"Method")," instances.")))}d.isMDXComponent=!0}}]);